#+title: My Emacs Config
#+author: Bohan Li
#+email: jim.jd.davis@gmail.com
#+property: header-args :results silent
#+options: toc:nil

* Table of Contents                                                     :TOC:
- [[#about][About]]
- [[#early-initel][early-init.el]]
  - [[#header][Header]]
  - [[#speed-tweaks][Speed tweaks]]
  - [[#package-utilities][Package utilities]]
  - [[#early-tweaks-on-appearance][Early tweaks on appearance]]
  - [[#provide-early-initel][Provide =early-init.el=]]
- [[#initel][init.el]]
  - [[#header-1][Header]]
  - [[#general-settings][General Settings]]
  - [[#appearance][Appearance]]
  - [[#read-completion][Read-Completion]]
  - [[#projects][Projects]]
  - [[#version-control][Version Control]]
  - [[#editing][Editing]]
  - [[#latex][Latex]]
  - [[#org-mode][Org-mode]]
  - [[#programming][Programming]]
  - [[#terminalshell][Terminal/Shell]]
  - [[#tty-emacs-specific][TTY Emacs Specific]]
  - [[#bufferwindow-management][Buffer/Window Management]]
  - [[#miscellaneous-packages][Miscellaneous Packages]]
  - [[#final-touch][Final Touch]]
  - [[#provide-initel][Provide init.el]]

* About
  This org file contains my Emacs configurations. Once tangled it "compiles" into
  init.el (and possibly early-init.el, depending on the Emacs version), which can
  be used by Emacs at startup. Parts of the file are inspired by Andrey's dot-file
  available at [[https://github.com/andreyorst/dotfiles][Github]]. 

* early-init.el
  :properties:
  :header-args: :tangle "./early-init.el"
  :end:

  Early-init.el was introduced since Emacs 27. Most configurations
  should still belong to init.el, but this makes it possible to change
  things at a very early stage, sometimes quite helpful.

** Header
   #+begin_src elisp
     ;;; early-init.el --- Early configs -*- lexical-binding: t; buffer-read-only:t -*-
     ;;;
     ;;; Commentary:
     ;;; This file is auto-generated from an org file. Please do not change this file directly.
     ;;;
     ;;; Code:
   #+end_src

** Speed tweaks
   Tweak garbage collection and also other things for a better
   performance. This may need to be changed if on a relatively
   resource-constraint machine.

   #+begin_src elisp
     (setq gc-cons-threshold (* 50 1024 1024))
     (setq read-process-output-max (* 2048 2048))
   #+end_src

** Package utilities
*** Straight.el
    Straight.el helps managing packages in a very convenient yet
    consistent way. Bootstrap it so we can use it later to require
    packages. 

    We are using the develop branch of the straight repo. Also by default
    use straight with use-package.
    #+begin_src elisp
      (defvar straight-repository-branch "master")
      (defvaralias 'comp-deferred-compilation-black-list 'comp-deferred-compilation-deny-list)

      (defvar bootstrap-version)
      (let ((bootstrap-file
	     (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	    (bootstrap-version 5))
	(unless (file-exists-p bootstrap-file)
	  (with-current-buffer
	      (url-retrieve-synchronously
	       "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	       'silent 'inhibit-cookies)
	    (goto-char (point-max))
	    (eval-print-last-sexp)))
	(load bootstrap-file nil 'nomessage))

      (setq straight-cache-autoloads t)
      (setq straight-disable-native-compilation t)
    #+end_src

*** Use-package.el
    Use use-package for much easier package configuration with auto-loading.

    #+begin_src elisp
      (straight-use-package 'use-package)
      (setq use-package-verbose nil)
      (setq straight-use-package-by-default t)
    #+end_src

*** Others
    Do not load package.el since we are not using it.
    #+begin_src elisp
      (setq package-enable-at-startup nil)
    #+end_src

** Early tweaks on appearance
   No menu, tool, scroll bars, please. 
   #+begin_src elisp
     (tool-bar-mode -1)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
   #+end_src

** Provide =early-init.el=
   #+begin_src elisp
     (provide 'early-init)
     ;;; early-init.el ends here
   #+end_src

* init.el
  :properties:
  :header-args: :tangle "./init.el"
  :end:

  Init.el should be placed in =user-emacs-directory=. By default it's
  in =~/.emacs.d/=. 

** Header
   #+begin_src elisp
     ;;; init.el --- My emacs configs -*- lexical-binding: t; buffer-read-only:t -*-
     ;;;
     ;;; Commentary:
     ;;; This file is auto-generated from an org file. Please do not change this file directly.
     ;;;
     ;;; Code:
   #+end_src

   This can help benchmark initialization time. Remove the disabled mark to use it.
   #+begin_src elisp
     (use-package benchmark-init
       :disabled ;; comment this line to benchmark at startup
       :config
       (benchmark-init/activate))
   #+end_src

** General Settings
*** Default files
    Load =early-init.el= manually if it is not supported by this version of Emacs.
    #+begin_src elisp
      (unless (featurep 'early-init)
	(let ((early-init-file (expand-file-name "early-init.el" user-emacs-directory)))
	  (when (file-exists-p early-init-file) (load early-init-file))))
    #+end_src 

    Define a separate file for customized variables. Create the file if it does
    not exist.  If anything is deleted in =init.el=, the saved customized values
    would persist still. This is not great. Need to find a new way.

    #+begin_src elisp
      (defconst custom-file (expand-file-name "autogen-cus.el" user-emacs-directory))
      (unless (file-exists-p custom-file) (write-region "" nil custom-file))
      (load custom-file)
    #+end_src

    Do not do deferred compilation on autoload files. This is needed with =straight=
    for now.
    #+begin_src elisp
      (use-package comp
	:straight (:type built-in))
      (add-to-list 'comp-deferred-compilation-deny-list ".*autoload.*")
      (setq comp-async-report-warnings-errors nil)
    #+end_src

*** History saving
    Using recentf-mode. Because we are using =prescient= so no need for =savehist-mode=.
    #+begin_src elisp
      (recentf-mode 1)
    #+end_src

*** Other
    Set recenter positions so we can see a portion of the previous/next page.
    #+begin_src elisp
      (setq recenter-positions '(middle 0.15 0.85))
    #+end_src

    The default scroll amount is too fast for me. 
    #+begin_src elisp
      (setq mouse-wheel-scroll-amount
	    '(3 ((shift) . 1) ((meta)) ((control) . text-scale))
	    mouse-wheel-progressive-speed nil)
    #+end_src

    Resize by pixels. 
    #+begin_src elisp
      (setq frame-resize-pixelwise t)
    #+end_src

    Allow following symbolic links.
    #+begin_src elisp
      (setq vc-follow-symlinks t)
    #+end_src

    Allow recursive minibuffer.
    #+begin_src elisp
      (setq enable-recursive-minibuffers  t)
    #+end_src

** Appearance
   Set up theme, mode-line, tab-bar, etc. I usually set them up before
   other packages, since some packages do not play nice with themes and
   may get reset if a theme is loaded after the package is initialized.

*** All the icons
    Use icons in Emacs for a better look. 
    #+begin_src elisp
      (use-package all-the-icons)
    #+end_src

*** Mode-line
    Currently using =doom-modeline=. I also liked =telephone-line= too.
    #+begin_src elisp
      (use-package doom-modeline
	:custom
	(doom-modeline-height 30)
	(doom-modeline-buffer-file-name-style 'truncate-with-project)
	:config
	;; do not display the host name, it's often too long.
	(doom-modeline-def-segment remote-host-no-host
	  "Hostname for remote buffers."
	  (when default-directory
	    (when (file-remote-p default-directory 'host)
	      (propertize
	       " @"
	       'face (if (doom-modeline--active)
			 'doom-modeline-host
		       'mode-line-inactive)))))
	(doom-modeline-def-modeline 'no-host-main
	  '(bar workspace-name window-number modals matches buffer-info
		remote-host-no-host buffer-position word-count parrot selection-info)
	  '(objed-state persp-name battery grip irc mu4e gnus github debug
			lsp input-method indent-info process vcs checker misc-info))

	(defun setup-custom-doom-modeline ()
	  "Setup the customized modeline for doom modeline."
	  (doom-modeline-set-modeline 'no-host-main 'default))

	(add-hook 'doom-modeline-mode-hook 'setup-custom-doom-modeline)
	(doom-modeline-mode 1))
    #+end_src

*** Themes
    I quite like =doom-themes= since they provide a modern look to Emacs.
    #+begin_src elisp
      (use-package doom-themes
	:config
	(load-theme 'doom-one t)
	(set-face-attribute 'header-line nil :background "#22262b")
	(set-face-attribute 'tab-bar nil :background "#151823")
	(set-face-attribute 'tab-bar-tab nil :background "#22262b")
	(set-face-attribute 'tab-bar-tab-inactive nil :background "#182126")
	(set-face-attribute 'highlight nil
			    :background "#2257a0"
			    :foreground "#dfdfdf"
			    :distant-foreground "#1b2229"
			    :weight 'normal)
	(set-face-attribute 'completions-annotations nil
			    :slant 'normal))
    #+end_src

*** Font
    The Fira font works very well both in terminal and in graphic emacs.
    #+begin_src elisp
      (add-to-list 'default-frame-alist '(font . "Fira Code-11"))
    #+end_src

*** Tabs

**** Centaur tabs
     Use Centaur tabs. It has a modern look, but sometimes does not play that
     well with other packages. Need to be careful.

     This is currently not turned on by default since I just feel tabs may not
     be that useful after all.

     Define a function to check if centaur tabs mode is active, if we want to
     call the function =centaur-tabs-local-mode=, since it will fail if not in
     centaur tabs mode.

     #+begin_src elisp
       (defun jd:disable-centaur-tabs ()
	 (when centaur-tabs-mode
	   (centaur-tabs-local-mode)))
     #+end_src

     #+begin_src elisp
       (use-package centaur-tabs
	 :defer t
	 :commands (centaur-tabs-mode centaur-tabs-local-mode)
	 :custom
	 ((centaur-tabs-height 24)
	  (centaur-tabs-set-bar 'left))
	 :bind
	 (("C-<prior>" . centaur-tabs-backward)
	  ("C-<next>" . centaur-tabs-forward))
	 :hook
	 ((gud-mode . jd:disable-centaur-tabs)
	  (gud-locals-mode . jd:disable-centaur-tabs)
	  (gud-inferior-io-mode . jd:disable-centaur-tabs)
	  (gud-frames-mode . jd:disable-centaur-tabs)
	  (gud-breakpoints-mode . jd:disable-centaur-tabs))
	 :config
	 (defun jd:centaur-tabs-buffer-groups ()
	   "Customize centaur tabs group rules."
	   (list
	    (cond
	     ((or (derived-mode-p 'eshell-mode)
		  (derived-mode-p 'shell-mode)
		  (derived-mode-p 'vterm-mode)
		  (derived-mode-p 'term-mode))
	      "Term/Shell")
	     ((memq major-mode '(org-mode org-agenda-mode diary-mode))
	      "OrgMode")
	     ((or (memq major-mode '(magit-process-mode
				     magit-status-mode
				     magit-diff-mode
				     magit-log-mode
				     magit-file-mode
				     magit-blob-mode
				     magit-blame-mode))
		  (string-equal "COMMIT_EDITMSG" (buffer-name)))
	      "Magit")
	     ((string-equal "*" (substring (buffer-name) 0 1))
	      "Emacs")
	     (t
	      (centaur-tabs-get-group-name (current-buffer))))))
	 (advice-add 'centaur-tabs-buffer-groups :override #'jd:centaur-tabs-buffer-groups)
	 (when (featurep 'all-the-icons)
	   (setq centaur-tabs-set-icons t))
	 (centaur-tabs-headline-match))
     #+end_src

**** Tab bar
     Tab bars are quite useful in emacs to manage workspaces. But like tabs, I
     find myself not using them very often. Using =C-x t= as the prefix:

     #+begin_src elisp
       (use-package tab-bar
	 :bind (("C-x t s" . tab-bar-switch-to-tab)))
     #+end_src

*** Others
    Use a bar for cursors. Just a personal preference.
    #+begin_src elisp
      (setq-default cursor-type 'bar)
    #+end_src

** Read-Completion
*** Prescient
    Better and simpler ordering of candidates.
    #+begin_src elisp
      (use-package prescient
	:config
	(prescient-persist-mode +1))
    #+end_src
    
*** Selectrum
    Use =selectrum= for incremental completion.
    #+begin_src elisp
      (use-package selectrum
	:bind
	(("C-c C-r" . selectrum-repeat))
	:config
	(selectrum-mode +1))
    #+end_src

    Use prescient for ordering.
    #+begin_src elisp
      (use-package selectrum-prescient
	:if (featurep 'prescient)
	:config
	(selectrum-prescient-mode +1))
    #+end_src
    
*** Consult
    Useful functionalities for complete-read.
    #+begin_src elisp
      (use-package consult
	:bind (;; C-c bindings (mode-specific-map)
	       ("C-c m" . consult-mode-command)
	       ("C-c o" . consult-outline)
	       ("C-c i" . consult-imenu)
	       ;; C-x bindings (ctl-x-map)
	       ("C-x M-:" . consult-complex-command)
	       ("C-x b" . consult-buffer)
	       ("C-x 4 b" . consult-buffer-other-window)
	       ("C-x 5 b" . consult-buffer-other-frame)
	       ("C-x r x" . consult-register)
	       ("C-x r b" . consult-bookmark)
	       ;; M-g bindings (goto-map)
	       ("M-g g" . consult-goto-line)
	       ("M-g M-g" . consult-goto-line)
	       ("M-g m" . consult-mark)
	       ("M-g k" . consult-global-mark)
	       ("M-g e" . consult-error)
	       ("M-g f" . consult-flymake)
	       ;; M-s bindings (search-map)
	       ("M-s g" . consult-ripgrep)      ;; Alternatives: consult-grep, consult-ripgrep
	       ("M-s f" . consult-find)          ;; Alternatives: consult-locate, my-fdfind
	       ("M-s l" . consult-line)
	       ("M-s m" . consult-multi-occur)
	       ("M-s k" . consult-keep-lines)
	       ("M-s u" . consult-focus-lines)
	       ;; Other bindings
	       ("M-y" . consult-yank-pop)
	       ("<help> a" . consult-apropos)
	       ("C-s" . consult-line))
	:init
	(setq register-preview-delay 0
	      register-preview-function #'consult-register-preview)
	:config
	(setq consult-preview-key (kbd "C-l"))
	(setq consult-narrow-key "<")
	(autoload 'projectile-project-root "projectile")
	(setq consult-project-root-function #'projectile-project-root))
    #+end_src

    Use consult with xref. This is currently only in my local consult repo.
    #+begin_src elisp
      (use-package consult-xref
	:straight consult
	:config
	(setup-consult-xref))
    #+end_src

*** Marginalia
    Add annotations to minibuffer completions.
    #+begin_src elisp
      (use-package marginalia
	:bind (:map minibuffer-local-map
		    ("C-M-a" . marginalia-cycle))
	:init
	(marginalia-mode)
	(advice-add #'marginalia-cycle :after
		    (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit))))
	(setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
    #+end_src

*** embark
    Enables useful actions to minibuffer completions.
    #+begin_src elisp
      (use-package embark
	:bind
	("C-o" . embark-act))

      (use-package embark-consult
	:after (embark consult)
	:demand t
	:hook
	(embark-collect-mode . embark-consult-preview-minor-mode))
    #+end_src
    
** Projects
*** Projectile
    Use projectile to manage projects in Emacs. Maybe will consider using
    =project.el= later. 
    #+begin_src elisp
      (use-package projectile
	:bind-keymap
	("C-c p" . projectile-command-map)
	:config
	(projectile-mode)
	(use-package counsel-projectile
	  :if (featurep 'counsel)
	  :config
	  (counsel-projectile-mode t)))
    #+end_src

*** Ripgrep
    Ripgrep is very fast and convenient when searching in a project. 
    #+begin_src elisp
      (use-package ripgrep)
    #+end_src

*** Treemacs
    Side bar to navigate files in a project. Quite helpful at times, and
    looks modern.  It might conflict with other window management
    packages, so need to be careful in config.
    #+begin_src elisp
      (use-package treemacs
	:commands treemacs
	:custom
	((treemacs-width 34)
	 (treemacs-no-delete-other-windows t)
	 (treemacs-space-between-root-nodes nil))
	:custom-face
	(treemacs-root-face ((t (:inherit font-lock-string-face :weight bold :height 1.1))))
	:config
	(when (window-system) (treemacs-resize-icons 20))
	(use-package treemacs-magit))
    #+end_src

** Version Control
   Use =magit= for version control (of course). 

*** Magit
    Customize magit a bit to my liking.
    #+begin_src elisp
      (use-package magit
	:defer t
	:bind
	("C-x g" . magit-status)
	:custom
	((ediff-diff-options "-w")
	 (ediff-split-window-function #'split-window-horizontally)
	 (ediff-window-setup-function #'ediff-setup-windows-plain)
	 (magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1))
	:config
	(use-package magithub
	  :config
	  (magithub-feature-autoinject t)))
    #+end_src

*** Git gutter
    Subtly show diff info on the margin. Works with both terminal and graphic Emacs.
    #+begin_src elisp
      (use-package git-gutter
	:custom
	((git-gutter:added-sign "|")
	 (git-gutter:modified-sign "|")
	 (git-gutter:deleted-sign "|"))
	:config
	(global-git-gutter-mode))
    #+end_src

** Editing
*** Yasnippet
    Useful snippets. Also helps with company mode completion.
    #+begin_src elisp
      (use-package yasnippet
	:config
	(yas-global-mode t))
    #+end_src
    
*** Company
    Complete anything!

    In gud-mode, we don't want company to auto show up, since it makes
    things super laggy. Define a function to disable it.
    #+begin_src elisp
      (defun jd:disable-company-idle-delay ()
	(setq-local company-idle-delay nil))
    #+end_src

    #+begin_src elisp
      (use-package company
	:demand
	:custom
	((company-idle-delay 0.05)
	 (company-show-numbers t)
	 (company-minimum-prefix-length 2)
	 (company-tooltip-align-annotations t)
	 (company-tooltip-maximum-width 120))
	:bind
	(("C-M-i" . company-complete)
	 ("C-<tab>" . company-complete)
	 :map company-active-map
	 ("C-n" . company-select-next)
	 ("C-p" . company-select-previous))
	:hook
	((after-init . global-company-mode)
	 (gud-mode . jd:disable-company-idle-delay))
	:config
	(dotimes (i 10)
	  (define-key company-active-map (kbd (format "C-%d" i)) 'company-complete-number)))
    #+end_src

    Use =company-box= if we are not using TTY Emacs.
    #+begin_src elisp
      (use-package company-box
	:if window-system
	:hook (company-mode . company-box-mode))
    #+end_src

*** Spell Check
    Use flyspell for spell check. =wucuo.el= helps improving things for
    on-the-fly checking, but can be annoying at times for programming, as
    we do not always use (combinations of) full words. 

    #+begin_src elisp
      (use-package wucuo
	:hook
	((text-mode . wucuo-start))
	:config
	(cond
	 ((executable-find "aspell")
	  ;; you may also need `ispell-extra-args'
	  (setq ispell-program-name "aspell"))
	 ((executable-find "hunspell")
	  (setq ispell-program-name "hunspell"))))
    #+end_src

    Use =flyspell-correct.el= for easy batch correction. =C-.= and =C-,=
    are set manually to nil to avoid conflicts with my xref shortcuts.

    #+begin_src elisp
      (use-package flyspell-correct
	:bind
	(:map flyspell-mode-map
	      ("C-;" . flyspell-correct-wrapper)
	      ("C-," . nil)
	      ("C-." . nil)))
    #+end_src

*** Undo-tree
    Helps with a visualized undo tree. 

    #+begin_src elisp
      (use-package undo-tree
	:config
	(global-undo-tree-mode))
    #+end_src

*** Smartparens
    Automatically highlights and inserts parens. Add support for curly
    braces (automatically add a newline there) and c comment pairs.

    #+begin_src elisp
      (use-package smartparens-config
	:straight (smartparens)
	:config
	(sp-with-modes
	    '(c-mode c++-mode)
	  (sp-local-pair "{" nil
			 :post-handlers '(("||\n[i]" "RET")))
	  (sp-local-pair "/*" "*/"))
	(smartparens-global-mode t)
	(show-smartparens-global-mode t))
    #+end_src

*** Multiple cursors
    #+begin_src elisp
      (use-package multiple-cursors
	:bind
	(("C-S-c C-S-c" . mc/edit-lines)
	 ("C->" . mc/mark-next-like-this)
	 ("C-<" . mc/mark-previous-like-this)
	 ("C-c C-<" . mc/mark-all-like-this)))
    #+end_src

*** Others
    Set the fill column width to be 80 for the general case. 
    #+begin_src elisp
      (setq-default fill-column 80)
      (setq column-number-mode t)
    #+end_src

** Latex
   Use =auctex=.
   #+begin_src elisp
     (use-package auctex
       :hook
       (tex-mode . TeX-mode)
       (TeX-mode . TeX-source-correlate-mode))
   #+end_src

** Org-mode
   I am quite new to org mode, but there are some things already quite useful.

*** Install orgmode
    Emacs comes with a default yet quite old version of org. Install the new one.
    =straight.el= helps with installing it at the first time. 

    #+begin_src elisp
      (use-package org
	:defer t
	:custom
	(org-return-follows-link t))
    #+end_src

*** TOC
    Auto insert a TOC when saving. Very helpful for GitHub org files. 
    #+begin_src elisp
      (use-package toc-org
	:hook
	(org-mode . toc-org-mode))
    #+end_src

** Programming
   Setups for programming tools.
*** Xref setup
    =xref= is the built-in functionality that Emacs uses. I have a few tweaks to
    make it work better with my work flow.

    First, define a custom function that allows opening the definition at other
    window with a prefix argument.
    #+begin_src elisp
      (defun jd:xref-find-definitions (arg)
	"Custom function to find definitions in other window with ARG is non nil."
	(interactive "P")
	(let ((current-prefix-arg nil)
	      (xref-prompt-for-identifier nil))
	  (if arg
	      (call-interactively 'xref-find-definitions-other-window)
	    (call-interactively 'xref-find-definitions))))
    #+end_src

    Similarly, define a custom function that do not prompt the user when the
    find reference function has only just one result.
    #+begin_src elisp
      (defun jd:xref-find-references (arg)
	"Find references with no prefix arg."
	(interactive "p")
	(let ((current-prefix-arg nil)
	      (xref-prompt-for-identifier (> arg 1)))
	  (call-interactively 'xref-find-references)))
    #+end_src

    By default, xref has a marker ring that allows users to trace back. Add a
    new marker ring here to allow tracing forward after going back (like a
    redo).
    #+begin_src elisp
      (defvar jd--xref-forward-marker-ring)
      (setq jd--xref-forward-marker-ring (make-ring xref-marker-ring-length))

      (defun jd:xref-clear-fwd-marker-ring ()
	"Clear the forward marker ring for xref."
	(when (not (ring-empty-p jd--xref-forward-marker-ring))
	  (setq jd--xref-forward-marker-ring (make-ring xref-marker-ring-length))))

      (defun jd:xref-pop-marker-stack ()
	"Pop a marker from xref marker ring, and save it in the forward marker ring."
	(interactive)
	(let ((ring xref--marker-ring))
	  (when (ring-empty-p ring)
	    (user-error "Marker stack is empty"))
	  (let ((marker (ring-remove ring 0)))
	    (ring-insert jd--xref-forward-marker-ring (point-marker))
	    (switch-to-buffer (or (marker-buffer marker)
				  (user-error "The marked buffer as been deleted")))
	    (goto-char (marker-position marker))
	    (set-marker marker nil nil)
	    (run-hooks 'xref-after-return-hook))))

      (defun jd:xref-pop-fwd-marker-stack ()
	"Pop the marker from the xref fwd marker stack, and save in the xref marker ring."
	(interactive)
	(let ((ring jd--xref-forward-marker-ring))
	  (when (ring-empty-p ring)
	    (user-error "Forward marker stack is empty"))
	  (let ((marker (ring-remove ring 0)))
	    (ring-insert xref--marker-ring (point-marker))
	    (switch-to-buffer (or (marker-buffer marker)
				  (user-error "The marked buffer as been deleted")))
	    (goto-char (marker-position marker))
	    (set-marker marker nil nil)
	    (run-hooks 'xref-after-return-hook))))
    #+end_src

    Finally set up xref with the above tweaks. The key mappings are a bit
    different with the default ones.
    #+begin_src elisp
      (use-package xref
	:demand t
	:bind
	(("M-." . jd:xref-find-definitions)
	 ("M-," . jd:xref-find-references)
	 ("C-," . xref-pop-marker-stack)
	 ("C-." . jd:xref-pop-fwd-marker-stack))
	:config
	(advice-add 'xref-pop-marker-stack :override #'jd:xref-pop-marker-stack)
	(advice-add 'xref-push-marker-stack :before #'jd:xref-clear-fwd-marker-ring))
    #+end_src

*** eldoc
    Set up eldoc so it does not automatically use the echo buffer, but only do so
    when asked.

    #+begin_src elisp
      (use-package eldoc
	:init
	(defun jd:eldoc ()
	  "Ask eldoc to show in the echo area."
	  (interactive)
	  (when eldoc-mode
	    (let ((eldoc-display-functions 'eldoc-display-in-echo-area)
		  (last-command this-command)
		  (this-command nil)
		  (eldoc--last-request-state nil))
	      (eldoc-print-current-symbol-info))))
	:custom
	((eldoc-idle-delay 0.1))
	:config
	(setq eldoc-message-commands
	      (make-vector eldoc-message-commands-table-size 0))
	(eldoc-add-command "jd:eldoc")
	:bind
	(("C-c h" . jd:eldoc))
	:demand t)

    #+end_src
  
*** Eglot
    =eglot= is an LSP client that uses mostly built-in emacs functionalities.
    It is much easier to manage than =lsp-mode= and more light-weight.
    #+begin_src elisp
      (use-package project)
      (use-package eglot
	:straight (:no-native-compile t)
	:custom-face
	(eglot-highlight-symbol-face ((t (:background "#20395a" :weight bold))))
	:custom
	((eglot-send-changes-idle-time 0.2))
	:hook
	((c-mode . eglot-ensure)
	 (c++-mode . eglot-ensure))
	:config
	(add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd")))
    #+end_src

*** Compiling
    #+begin_src elisp
      (setq compilation-scroll-output 'first-error)
      (setq compilation-auto-jump-to-first-error t)
      (setq compilation-skip-threshold 1)
    #+end_src

    Define a function to auto-close compilation window if compilation is successful.
    #+begin_src elisp
      (defcustom jd--compile-autoclose-time 1 "Seconds to wait before auto close the compilation buffer.")
      (defun jd:compile-auto-close (buffer string)
	"Hook to auto close compilation BUFFER. STRING is the returned message."
	(cond ((and (string-match "finished" string) (string-equal (buffer-name) "*compilation*"))
	       (message "Build may be successful: closing window.")
	       (run-with-timer jd--compile-autoclose-time nil 'delete-window (get-buffer-window buffer t)))
	      (t (message "Compilation exited abnormally: %s" (string-trim string)))))

      (push 'jd:compile-auto-close compilation-finish-functions)
    #+end_src

    Define a function to toggle the skip threshold of compilation buffer:
    #+begin_src elisp
      (defun jd:toggle-compile-skip-thresh()
	"Toggle the compilation skip threshold."
	(interactive)
	(if (eq compilation-skip-threshold 1)
	    (progn (setq compilation-skip-threshold 2)
		   (message "Skip threshold set to errors"))
	  (progn (setq compilation-skip-threshold 1)
		 (message "Skip threshold set to warnings"))))
    #+end_src

    Support xterm coloring in compilation buffers:
    #+begin_src elisp
      (use-package xterm-color)
      (setq compilation-environment '("TERM=xterm-256color"))
      (defun jd:advice-compilation-filter (f proc string)
	(funcall f proc (xterm-color-filter string)))
      (advice-add 'compilation-filter :around #'jd:advice-compilation-filter)
    #+end_src
    
*** C/C++ programming
    Clangd language server is used with =eglot= for C programming.
    
**** Clang-format
     Set up clang format so it auto-formats on save, but only for c mode.
     This is not needed with =lsp-mode= or =eglot=.

     #+begin_src elisp
       (use-package clang-format
	 :custom
	 ((clang-format-style "file")
	  (clang-format-executable "clang-format-7")))
     #+end_src

**** Others
     Prefer using =//= instead of =/* */=.
     #+begin_src elisp
       (add-hook 'c-mode-common-hook (lambda ()
				       (c-toggle-comment-style -1)))
     #+end_src

*** GDB set up
    Use gdb many windows. But do not pop-up.
    #+begin_src elisp
      (use-package gdb-mi
	:custom
	((gdb-display-io-nopopup t)
	 (gdb-many-windows t)
	 (gdb-restore-window-configuration-after-quit t)))
    #+end_src

*** Others
    Display line number mode for programming.
    #+begin_src elisp
      (use-package display-line-numbers
	:demand t
	:custom
	(display-line-numbers-width 4)
	:hook
	((prog-mode . display-line-numbers-mode)))
    #+end_src

    Display the current function name.

    #+begin_src elisp
      (defun jd:display-which-func ()
	(interactive)
	(message (which-function)))
      (use-package which-func
	:demand t
	:bind
	(("C-c f" . jd:display-which-func)))
    #+end_src

** Terminal/Shell
   =vterm= emulates the terminal well and enables many Emacs key-bindings
   as a buffer.
   #+begin_src elisp
     (defun vterm-counsel-yank-pop-action (orig-fun &rest args)
       (if (equal major-mode 'vterm-mode)
	   (let ((inhibit-read-only t)
		 (yank-undo-function (lambda (_start _end) (vterm-undo))))
	     (cl-letf (((symbol-function 'insert-for-yank)
			(lambda (str) (vterm-send-string str t))))
	       (apply orig-fun args)))
	 (apply orig-fun args)))

     (use-package vterm
       :commands vterm
       :if module-file-suffix
       :custom
       (vterm-kill-buffer-on-exit t)
       :config
       (advice-add 'counsel-yank-pop-action :around #'vterm-counsel-yank-pop-action))
   #+end_src

** TTY Emacs Specific
*** Mouse
    In TTY Emacs, I still want to use mouse sometimes.
    #+begin_src elisp
      (unless window-system
	(xterm-mouse-mode t)
	(setq mouse-sel-mode t
	      xterm-set-window-title t))
    #+end_src

*** Clipetty
    =clipetty= helps transferring the paste board from a tty Emacs to a
    remote client.
    #+begin_src elisp
      (use-package clipetty
	:bind
	("M-w" . clipetty-kill-ring-save))
    #+end_src
    
*** Keys
    For company mode, we need =C-0= to =C-9=, but their codes are not
    defined in the key-map.
    #+begin_src elisp
      (dotimes (i 10)
	(define-key input-decode-map (format "\e[%d;5u" (+ i 48)) (kbd (format "C-%d" i))))
    #+end_src

** Buffer/Window Management
*** =ace-window=
    Jumping among windows. 
    #+begin_src elisp
      (use-package ace-window
	:bind
	("M-o" . ace-window))
    #+end_src

*** Window movements
    Use Shift + arrows to move among windows. 
    #+begin_src elisp
      (windmove-default-keybindings)
    #+end_src
*** Side windows
    Define the rules for side windows.

    Do not preserve height for top/bottom, and width for left/right.
    #+begin_src elisp
      (defvar jd--par-sidewin-top-bot
	'(preserve-size . (nil . nil)))

      (defvar jd--par-sidewin-left-right
	'(preserve-size . (nil . nil)))
    #+end_src

    Allow fit window to buffer horizontally. Also resize pixel-wise.
    #+begin_src elisp
      (setq fit-window-to-buffer-horizontally t)
      (setq window-resize-pixelwise t)
    #+end_src

    Define the function to fit buffer width with constraints. 
    #+begin_src elisp
      (defcustom jd--fit-width-min-ratio 0.2 "Minimum width of a window to fit to buffer.")
      (defcustom jd--fit-width-max-ratio 0.5 "Maximum width of a window to fit to buffer.")

      (defun jd:fit-window-to-buffer-ratio (&optional window)
	"Fit WINDOW to buffer with ratio constraints."
	(let ((min-width (ceiling (* (frame-width) jd--fit-width-min-ratio)))
	      (max-width (floor (* (frame-width) jd--fit-width-max-ratio))))
	  (fit-window-to-buffer window nil nil max-width min-width nil)
	  (unless (window-system) (window-resize window 1 t))))
    #+end_src

    Define the variable to determine width with a fixed ratio. (Currently not used).
    #+begin_src elisp
      (defcustom jd--fixed-width-ratio 0.4 "Fixed width ratio for sidewindows")
    #+end_src

    Set =display-buffer-alist= to display certain buffers in side windows. 
    #+begin_src elisp
      (setq display-buffer-alist 
	    `(("\\*\\(.*[hH]elp\\|undo-tree.*\\)\\*" 
	       display-buffer-in-side-window
	       (side . right)
	       (slot . 0)
	       (window-width . jd:fit-window-to-buffer-ratio)
	       jd--par-sidewin-left-right)
	      ("\\*\\(grep\\|Completions\\|compilation\\|Python Check\\|code-review-gerrit-comment\\)\\*"
	       display-buffer-in-side-window
	       (side . bottom)
	       (slot . 0)
	       jd--par-sidewin-top-bot)))
    #+end_src

** Miscellaneous Packages
*** Which-key mode
    Displays the key bindings after a prefix. 

    #+begin_src elisp
      (use-package which-key
	:config
	(which-key-mode t))
    #+end_src
*** Sudo edit
    Makes it easier to edit files that needs sudo.

    #+begin_src elisp
      (use-package sudo-edit
	:commands (sudo-edit sudo-edit-find-file))
    #+end_src

*** Pyim input method.
    #+begin_src elisp
      (use-package pyim)
      (setq default-input-method "pyim")

      (defun jd:pyim-basedict-enable ()
	"Add basedict to pyim."
	(interactive)
	(let* ((file (concat (file-name-directory
			      (straight--repos-dir "pyim-basedict"))
			     "pyim-basedict.pyim")))
	  (when (file-exists-p file)
	    (if (featurep 'pyim)
		(pyim-extra-dicts-add-dict
		 `(:name "Basedict-elpa"
			 :file ,file
			 :coding utf-8-unix
			 :dict-type pinyin-dict
			 :elpa t))
	      (message "pyim 没有安装，pyim-basedict 启用失败。")))))

      (use-package pyim-basedict
	:config
	(jd:pyim-basedict-enable))

      (defun jd:pyim-greatdict-enable ()
	"Add greatdict to pyim."
	(interactive)
	(let* ((file (concat (file-name-directory
			      (straight--repos-dir "pyim-greatdict"))
			     "pyim-greatdict.pyim.gz")))
	  (when (file-exists-p file)
	    (if (featurep 'pyim)
		(pyim-extra-dicts-add-dict
		 `(:name "Greatdict-elpa"
			 :file ,file
			 :coding utf-8-unix
			 :dict-type pinyin-dict
			 :elpa t))
	      (message "pyim 没有安装，pyim-greatdict 启用失败。")))))

      (use-package pyim-greatdict
	:straight (:type git
			 :host github
			 :repo "tumashu/pyim-greatdict")
	:config
	(jd:pyim-greatdict-enable))

    #+end_src

*** Burly bookmark management
    #+begin_src elisp
      (use-package burly
	:bind (("C-c b f" . burly-bookmark-frames)
	       ("C-c b o" . burly-open-bookmark)))
    #+end_src
    
** Final Touch
*** Thresholds
    Set gc thres back to a more normal value.
    #+begin_src elisp
      (setq gc-cons-threshold (* 2 1024 1024))
    #+end_src

*** Startup buffer
    Do not show the startup buffer.
    #+begin_src elisp
      (setq inhibit-startup-message t)
    #+end_src

*** Happy Emacs!
    Display a happy message :D
    #+begin_src elisp
      (defun jd:happy-message ()
	"Display a happy message!"
	(message "Happy Emacs!"))
      (advice-add 'display-startup-echo-area-message :override #'jd:happy-message)
    #+end_src

** Provide init.el

   #+begin_src elisp
     (provide 'init)
     ;;; init.el ends here
   #+end_src

   #  LocalWords:  Init init Andrey's parens Smartparens flyspell gud gc lsp
   #  LocalWords:  Magithub treemacs config Swiper swiper thres Clipetty
   #  LocalWords:  TOC

