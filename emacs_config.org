#+title: My Emacs Config
#+author: Bohan Li
#+email: jim.jd.davis@gmail.com
#+property: header-args :results silent

* About this file
This org file contains my emacs configurations. Once tangled it "compiles" into
init.el (and possibly early-init.el, depending on the emacs version), which can
be used by emacs at startup. Parts of the file are inspired by Andrey's dotfile
available at [[https://github.com/andreyorst/dotfiles][Github]]. 


* early-init.el
:properties:
:header-args: :tangle "./early-init.el"
:end:

Early-init.el was introduced since emacs 27. Most configurations
should still belong to init.el, but this makes it possible to change
things at a very early stage, sometimes quite helpful.

** Header
#+BEGIN_SRC elisp
  ;;; early-init.el --- Early configs -*- lexical-binding: t; buffer-read-only:t -*-
  ;;;
  ;;; Commentary:
  ;;; This file is auto-generated from an org file. Please do not change this file directly.
  ;;;
  ;;; Code:
#+END_SRC

** Speed tweaks
Tweak garbage collection and also other things for a better
performance. This may need to be changed if on a relatively
resource-contraint machine.

#+BEGIN_SRC elisp
  (setq gc-cons-threshold 200000000)
  (setq read-process-output-max (* 2048 2048))
#+END_SRC

** Package utilities
*** Straight.el
Straight.el helps managing packages in a very convenient yet
consistent way. Bootstrap it so we can use it later to require
packages. 

We are using the develop branch of the straight repo. Also by default
use straight with use-package.
#+BEGIN_SRC elisp
  (defvar straight-repository-branch "develop")
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

*** Use-package.el
Use use-package for much easier package configuration with autoloading.

#+BEGIN_SRC elisp
  (straight-use-package 'use-package)
  (setq use-package-verbose nil)
  (setq straight-use-package-by-default t)
#+END_SRC

*** Others
Do not load package.el since we are not using it.
#+BEGIN_SRC elisp
  (setq package-enable-at-startup nil)
#+END_SRC

** Early tweaks on appearance
No menu, tool, scroll bars, please. 
#+BEGIN_SRC elisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

** Provide =early-init.el=
#+BEGIN_SRC elisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+END_SRC


* init.el
:properties:
:header-args: :tangle "./init.el"
:end:

Init.el should be placed in =user-emacs-directory=. By default it's
in =~/.emacs.d/=. 

** Header
#+BEGIN_SRC elisp
  ;;; init.el --- My emacs configs -*- lexical-binding: t; buffer-read-only:t -*-
  ;;;
  ;;; Commentary:
  ;;; This file is auto-generated from an org file. Please do not change this file directly.
  ;;;
  ;;; Code:
#+END_SRC

** General Settings
*** Default files
 Load =early-init.el= manually if it is not supported by this version of emacs.
 #+BEGIN_SRC elisp
   (unless (featurep 'early-init)
     (let ((early-init-file (expand-file-name "early-init.el" user-emacs-directory)))
       (when (file-exists-p early-init-file) (load early-init-file))))
 #+END_SRC 

 Define a separate file for customized variables. Create the file if it
 does not exist. However we are not loading the file since I do not use
 the customize interface, but use this file to do configuration. Also,
 if anything is deleted in =init.el=, the saved customized values would
 not interfere.

 #+BEGIN_SRC elisp
   (defconst custom-file (expand-file-name "autogen-cus.el" user-emacs-directory))
   (unless (file-exists-p custom-file) (write-region "" nil custom-file))
 #+END_SRC

*** History saving
Save command and buffer history across sessions. 
#+BEGIN_SRC elisp
  (savehist-mode t)
#+END_SRC

*** Others
Set recenter positions so we can see a portion of the previous/next page.
#+BEGIN_SRC elisp
  (setq recenter-positions '(middle 0.15 0.85))
#+END_SRC

The default scroll amount is too fast for me. 
#+BEGIN_SRC elisp
  (setq mouse-wheel-scroll-amount
	'(3 ((shift) . 1) ((meta)) ((control) . text-scale))
	mouse-wheel-progressive-speed nil)
#+END_SRC

Resize by pixels. 
#+BEGIN_SRC elisp
  (setq frame-resize-pixelwise t)
#+END_SRC

** Appearance
Set up theme, modeline, tab-bar, etc. I usually set them up before
other packages, since some packages do not play nice with themes and
may get reset if a theme is loaded after the package is initialized.

*** All the icons
Use icons in emacs for a better look. 
#+BEGIN_SRC elisp
  (use-package all-the-icons)
#+END_SRC

*** Themes
I quite like doom themes since they provide a modern look to emacs. 
#+BEGIN_SRC elisp
  (use-package doom-themes
    :config
    (load-theme 'doom-one t))
#+END_SRC

*** Mode-line
Currently using telephone-line. I also liked doom-mode-line but it had
some bugs in updating the mode-line contents when I tested it.
#+BEGIN_SRC elisp
  (use-package telephone-line
    :custom
    ((telephone-line-height 22))
    :config
    (telephone-line-mode))
#+END_SRC

** Ivy Setup 
Ivy (together with counsel, swiper) makes completion quick and easy.

*** Basic ivy
#+BEGIN_SRC elisp
  (use-package ivy
    :bind
    (("C-c v" . ivy-push-view)
     ("C-c V" . ivy-pop-view)
     ("C-c C-r" . ivy-resume))
    :custom
    ((ivy-use-virtual-buffers t)
     (ivy-count-format "%d/%d")
     (ivy-wrap t)
     (ivy-height 10))
    :config
    (ivy-mode 1))
#+END_SRC
*** Counsel
Counsel provides various extended functions using ivy completion.
=counsel-mode= binds various shortcuts. 
#+BEGIN_SRC elisp
  (use-package counsel
    :demand
    :bind
    ("C-c k" . counsel-rg)
    :config
    (counsel-mode))
#+END_SRC
*** Swiper
Swiper should be installed already with ivy. Use it for searching. 
#+BEGIN_SRC elisp
  (use-package swiper
    :bind
    ("C-s" . swiper-isearch))
#+END_SRC
*** Enhancements
Various packages that enhance ivy.
 
=ivy-rich= displays more info in ivy. 
#+BEGIN_SRC elisp
  (use-package ivy-rich
    :config
    (ivy-rich-mode 1))
#+END_SRC

=smex= shows the most recent command in M-x. Specify where it saves
the history. This could be helpful if we have multiple emacs profiles.
#+BEGIN_SRC elisp
  (use-package smex
    :custom
    (smex-save-file (expand-file-name "smex-hist.el" user-emacs-directory))
    :config
    (smex-initialize))
#+END_SRC

Use =C-o= to use hydra with ivy
#+BEGIN_SRC elisp
  (use-package ivy-hydra)
#+END_SRC

Show xref results in ivy. Needs different set-up for older emacs. 
#+BEGIN_SRC elisp
  (use-package ivy-xref
    :if (>= emacs-major-version 27)
    :custom
    (xref-show-definitions-function #'ivy-xref-show-defs))
  
  (use-package ivy-xref
    :if (< emacs-major-version 27)
    :custom
    (xref-show-definitions-function #'ivy-xref-show-xrefs))
#+END_SRC

** Projects
*** Projectile
Use projectile to manage projects in emacs. Maybe will consider using
=project.el= later. 
#+BEGIN_SRC elisp
  (use-package projectile
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :config
    (projectile-mode))
#+END_SRC

**** Projectile with ivy
#+BEGIN_SRC elisp
  (use-package counsel-projectile
    :if (featurep 'counsel)
    :config
    (counsel-projectile-mode t))
#+END_SRC

*** Ripgrep
Ripgrep is very fast and convenient when searching in a project. 
#+BEGIN_SRC elisp
  (use-package rg
    :defer t)
#+END_SRC

*** Treemacs
Side bar to navigate files in a project. Quite helpful at times, and
looks modern.  It might conflict with other window management
packages, so need to be careful in config.

Also, if using telephone line, need to add a separator so it can
adjust treemacs modeline height.
#+BEGIN_SRC elisp
  (use-package treemacs
    :demand
    :bind
    ("C-x 1" . treemacs-delete-other-windows)
    :custom
    ((treemacs-width 34)
     (treemacs-no-delete-other-windows nil))
    :custom-face
    (treemacs-root-face ((t (:inherit font-lock-string-face :weight bold :height 1.1))))
    :config
    (when (featurep 'telephone-line)
      (setq treemacs-user-mode-line-format
	    '((:eval
	       (telephone-line-separator-render telephone-line-abs-left
						(telephone-line-face-map 'nil)
						(telephone-line-face-map 'accent)))
	      "Treemacs")))
    (treemacs-resize-icons 20))
#+END_SRC

** Version Control
Use magit for version control (of course). 

*** Transient
Required by magit. 
#+BEGIN_SRC elisp
  (use-package transient)
#+END_SRC

*** Magit
Customize magit a bit to my liking.
#+BEGIN_SRC elisp
  (use-package magit
    :demand
    :bind
    ("C-x g" . magit-status)
    :custom
    ((ediff-diff-options "-w")
     (ediff-split-window-function #'split-window-horizontally)
     (ediff-window-setup-function #'ediff-setup-windows-plain)
     (magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)))
#+END_SRC

*** Magithub
#+BEGIN_SRC elisp
  (use-package magithub
    :config
    (magithub-feature-autoinject t))
#+END_SRC
** Editing
** Terminal/Shell
=vterm= emulates the terminal well and enables many emacs key-bindings
as a buffer.
#+BEGIN_SRC elisp
  (use-package vterm
    :if module-file-suffix
    :custom
    (vterm-kill-buffer-on-exit t))
#+END_SRC

** TTY Emacs Specific
*** Mouse
In TTY emacs, I still want to use mouse sometimes.
#+BEGIN_SRC elisp
  (unless window-system
    (xterm-mouse-mode t)
    (setq mouse-sel-mode t
	  xterm-set-window-title t))

#+END_SRC
*** Clipetty
=clipetty= helps transfering the paste board from a tty emacs to a
remote client.
#+BEGIN_SRC elisp
  (use-package clipetty
    :bind
    ("M-w" . clipetty-kill-ring-save))
#+END_SRC
** Buffer/Window Management
*** =ace-window=
Jumping among windows. 
#+BEGIN_SRC elisp
  (use-package ace-window
    :bind
    ("M-o" . ace-window))
#+END_SRC
*** Window movements
Use Shift + arrows to move among windows. 
#+BEGIN_SRC elisp
  (windmove-default-keybindings)
#+END_SRC
*** Side windows
Define the rules for side windows.

Do not preserve height for top/bottom, and width for left/right.
#+BEGIN_SRC elisp
  (defvar jd--par-sidewin-top-bot
    '(preserve-size . (nil . nil)))

  (defvar jd--par-sidewin-left-right
    '(preserve-size . (nil . nil)))
#+END_SRC

Allow fit window to buffer horizontally. Also resize pixelwise.
#+BEGIN_SRC elisp
  (setq fit-window-to-buffer-horizontally t)
  (setq window-resize-pixelwise t)
#+END_SRC

Define the function to fit buffer width with constraints. 
#+BEGIN_SRC elisp
  (defcustom jd--fit-width-min-ratio 0.2 "Minimum width of a window to fit to buffer.")
  (defcustom jd--fit-width-max-ratio 0.5 "Maximum width of a window to fit to buffer.")

  (defun jd:fit-window-to-buffer-ratio (&optional window)
    "Fit WINDOW to buffer with ratio constraints."
    (let ((min-width (ceiling (* (frame-width) jd--fit-width-min-ratio)))
	  (max-width (floor (* (frame-width) jd--fit-width-max-ratio))))
      (fit-window-to-buffer window nil nil max-width min-width nil)))
#+END_SRC

Define the variable to determine width with a fixed ratio. (Currently not used).
#+BEGIN_SRC elisp
  (defcustom jd--fixed-width-ratio 0.4 "Fixed width ratio for sidewindows")
#+END_SRC

Set =display-buffer-alist= to display certain buffers in side windows. 
#+BEGIN_SRC elisp
  (setq display-buffer-alist 
  `(("\\*\\(.*[hH]elp\\|undo-tree.*\\)\\*" 
     display-buffer-in-side-window
     (side . right)
     (slot . 0)
     (window-width . jd:fit-window-to-buffer-ratio)
     jd--par-sidewin-left-right)
    ("\\*\\(grep\\|Completions\\|compilation\\|Python Check\\)\\*"
     display-buffer-in-side-window
     (side . bottom)
     (slot . 0)
     jd--par-sidewin-top-bot)))
#+END_SRC
** Miscellaneous Packages
*** Which-key mode
Displays the key bindings after a prefix. 
#+BEGIN_SRC elisp
  (use-package which-key
    :config
    (which-key-mode t))
#+END_SRC
** Provide =init.el=
#+BEGIN_SRC elisp
  (provide 'init)
  ;;; init.el ends here
#+END_SRC
