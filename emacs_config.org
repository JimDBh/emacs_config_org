#+title: My Emacs Config
#+author: Bohan Li
#+email: jim.jd.davis@gmail.com
#+property: header-args :results silent
#+options: toc:nil

* Table of Contents                                                     :TOC:
- [[#about][About]]
- [[#early-initel][early-init.el]]
  - [[#header][Header]]
  - [[#speed-tweaks][Speed tweaks]]
  - [[#package-utilities][Package utilities]]
  - [[#early-tweaks-on-appearance][Early tweaks on appearance]]
  - [[#provide-early-initel][Provide =early-init.el=]]
- [[#initel][init.el]]
  - [[#header-1][Header]]
  - [[#general-settings][General Settings]]
  - [[#essentials][Essentials]]
  - [[#appearance][Appearance]]
  - [[#read-completion][Read-Completion]]
  - [[#projects][Projects]]
  - [[#version-control][Version Control]]
  - [[#editing][Editing]]
  - [[#eaf][EAF]]
  - [[#latex--markdown][Latex & markdown]]
  - [[#pdf][PDF]]
  - [[#org-mode][Org-mode]]
  - [[#programming][Programming]]
  - [[#terminalshell][Terminal/Shell]]
  - [[#tty-emacs-specific][TTY Emacs Specific]]
  - [[#bufferwindow-management][Buffer/Window Management]]
  - [[#miscellaneous-packages][Miscellaneous Packages]]
  - [[#final-touch][Final Touch]]
  - [[#provide-initel][Provide init.el]]

* About
This org file contains my Emacs configurations. Once tangled (=M-x
org-babel-tangle=) it "compiles" into init.el (and possibly early-init.el,
depending on the Emacs version), which can be used by Emacs at startup.
  
* early-init.el
:properties:
:header-args: :tangle "./early-init.el"
:end:

Early-init.el was introduced since Emacs 27. Most configurations
should still belong to init.el, but this makes it possible to change
things at a very early stage, sometimes quite helpful.

** Header
#+begin_src elisp
  ;;; early-init.el --- Early configs -*- lexical-binding: t; buffer-read-only:t -*-
  ;;;
  ;;; Commentary:
  ;;; This file is auto-generated from an org file. Please do not change this file directly.
  ;;;
  ;;; Code:
#+end_src

** Speed tweaks
Tweak garbage collection and also other things for a better
performance. This may need to be changed if on a relatively
resource-constraint machine.

#+begin_src elisp
  (setq gc-cons-threshold (* 1000 1024 1024))
  (setq read-process-output-max (* 100 1024 1024))
#+end_src

** Package utilities
*** Straight.el
Straight.el helps managing packages in a very convenient yet
consistent way. Bootstrap it so we can use it later to require
packages.

We are using the develop branch of the straight repo. Also by default
use straight with use-package.
#+begin_src elisp
  (defvar straight-check-for-modifications '(find-when-checking))
  (defvar straight-repository-branch "develop")
  (defvaralias 'comp-deferred-compilation-black-list 'comp-deferred-compilation-deny-list)
  
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  
  (setq straight-cache-autoloads t)
  (setq straight-disable-native-compilation nil)
#+end_src

*** Use-package.el
Use use-package for much easier package configuration with auto-loading.

#+begin_src elisp
  (straight-use-package 'use-package)
  (setq use-package-verbose nil)
  (setq straight-use-package-by-default t)
#+end_src

*** Others
Do not load package.el since we are not using it.
#+begin_src elisp
  (setq package-enable-at-startup nil)
#+end_src

** Early tweaks on appearance
No menu, tool, scroll bars, please.
#+begin_src elisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** Provide =early-init.el=
#+begin_src elisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

* init.el
:properties:
:header-args: :tangle "./init.el"
:end:

Init.el should be placed in =user-emacs-directory=. By default it's
in =~/.emacs.d/=.

** Header
#+begin_src elisp
  ;;; init.el --- My emacs configs -*- lexical-binding: t; buffer-read-only:t -*-
  ;;;
  ;;; Commentary:
  ;;; This file is auto-generated from an org file. Please do not change this file directly.
  ;;;
  ;;; Code:
#+end_src

** General Settings

*** Benchmark
This can help benchmark initialization time. Remove the disabled mark to use it.
#+begin_src elisp
  (use-package benchmark-init
    :disabled ;; comment this line to benchmark at startup
    :config
    (benchmark-init/activate))
#+end_src

*** Default files
Load =early-init.el= manually if it is not supported by this version of Emacs.
#+begin_src elisp
  (unless (featurep 'early-init)
    (let ((early-init-file (expand-file-name "early-init.el" user-emacs-directory)))
      (when (file-exists-p early-init-file) (load early-init-file nil t))))
#+end_src

Define a separate file for customized variables. Create the file if it does
not exist.  If anything is deleted in =init.el=, the saved customized values
would persist still. This is not great. Need to find a new way.

#+begin_src elisp
  (defconst custom-file (expand-file-name "autogen-cus.el" user-emacs-directory))
  (unless (file-exists-p custom-file) (write-region "" nil custom-file))
  (load custom-file nil t)
#+end_src

#+begin_src elisp
  (use-package ironkey
    :straight (:type git :host github :repo "JimDBh/ironkey")
    :hook ((after-init . ironkey-update))
    :demand t
    :config
    (setq ironkey-iron-alist `((,(kbd "M-.") . nil)
                               (,(kbd "M-,") . nil)
                               (,(kbd "C-,") . nil)
                               (,(kbd "C-.") . nil)
                               (,(kbd "C-x p") . nil)))
    (ironkey-mode t))
#+end_src

#+begin_src elisp
  (use-package exec-path-from-shell
    :commands
    (exec-path-from-shell-initialize)
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src

#+begin_src elisp
  (advice-add 'jd:enable-terminal :after
              (lambda ()
                "editor env"
                (setenv "EDITOR" "emacsclient -c -t -a ''")))

  (advice-add 'jd:enable-graphic :after
              (lambda ()
                (setenv "EDITOR" "emacsclient -c -a ''")))
#+end_src

*** Server related
#+begin_src elisp
  (defvar server-init nil)
  (defvar check-timer nil)
  (when (getenv "OVERRIDE_EMACS_SERVER")
    (setq server-init t)
    (server-force-delete)
    (server-start)
    (setq use-package-always-demand t))

  (defvar last-display-p (display-graphic-p))

  (defun jd:enable-graphic ()
    t)
  (defun jd:enable-terminal ()
    t)
  (defun jd:disable-graphic ()
    t)
  (defun jd:disable-terminal ()
    t)

  (defun jd:check-display-settings ()
    (interactive)
    (dotimes (i 10)
      (define-key input-decode-map (format "\e[%d;5u" (+ i 48)) (kbd (format "C-%d" i))))
    (define-key input-decode-map "\e[96;5u" (kbd "C-`"))
    (unless (equal (display-graphic-p) last-display-p)
      (setq last-display-p (display-graphic-p))
      (if last-display-p
          (progn
            (jd:disable-terminal)
            (jd:enable-graphic))
        (jd:disable-graphic)
        (jd:enable-terminal))))

  (defun jd:check-display-settings-delayed ()
    (when check-timer
      (cancel-timer check-timer))
    (setq check-timer (run-with-timer 0.2 nil 'jd:check-display-settings)))

  (defun jd:init-display-settings ()
    (setq last-display-p (display-graphic-p))
    (if last-display-p
        (progn
          (jd:enable-graphic))
      (jd:enable-terminal)))

  (add-function :after after-focus-change-function 'jd:check-display-settings-delayed)
#+end_src

*** History saving
Using recentf-mode and save-hist mode.
#+begin_src elisp
  (use-package recentf
    :config
    (setq recentf-keep nil) ;; So remote files wouldn't be removed if cannot connect
    (setq recentf-filename-handlers '(abbreviate-file-name))
    (recentf-mode 1))

  (use-package savehist
    :init
    (savehist-mode))
#+end_src

*** Other
Don't show too much warnings
#+begin_src elisp
  (setq warning-minimum-level :emergency)
#+end_src

Set recenter positions so we can see a portion of the previous/next page.
#+begin_src elisp
  (setq recenter-positions '(middle 0.15 0.85))
#+end_src

The default scroll amount is too fast for me.
#+begin_src elisp
  (setq mouse-wheel-scroll-amount
        '(3 ((shift) . 1) ((meta)) ((control) . text-scale))
        mouse-wheel-progressive-speed nil)
#+end_src

Resize by pixels.
#+begin_src elisp
  (setq frame-resize-pixelwise t)
#+end_src

Allow following symbolic links.
#+begin_src elisp
  (setq vc-follow-symlinks t)
#+end_src

Allow recursive minibuffer.
#+begin_src elisp
  (setq enable-recursive-minibuffers  t)
#+end_src

Do not show advice warnings. Could be risky, but much less annoying.
#+begin_src elisp
  (setq ad-redefinition-action 'accept)
#+end_src

Do not ask me if a process is running.
#+begin_src elisp
  (setq confirm-kill-processes nil)
#+end_src

#+begin_src elisp
  (setq-default indent-tabs-mode nil)
#+end_src

Do not truncate lines by default.
#+begin_src elisp
  (setq-default truncate-lines nil)
#+end_src

Prefer newer files than already compiled ones.
#+begin_src elisp
  (setq load-prefer-newer t)
#+end_src

Ignore case when completing
#+begin_src elisp
  (setq completion-ignore-case t)
#+end_src

Use child frame for tooltips.
#+begin_src elisp
  (setq x-gtk-use-system-tooltips nil)
#+end_src

I usually just use Git
#+begin_src elisp
  (setq vc-handled-backends '(Git))
  (use-package vc-defer
    :config
    (setq vc-defer-backends '(Git)))
#+end_src

** Essentials
*** Hydra
#+begin_src elisp
  (use-package hydra)
#+end_src

** Appearance
Set up theme, mode-line, tab-bar, etc. I usually set them up before
other packages, since some packages do not play nice with themes and
may get reset if a theme is loaded after the package is initialized.

*** All the icons
Use icons in Emacs for a better look.
#+begin_src elisp
  (use-package all-the-icons)
#+end_src

*** Modeline
Currently using =doom-modeline=. I also liked =telephone-line= too.
#+begin_src elisp
  (use-package doom-modeline
    :custom
    (doom-modeline-height 46)
    (doom-modeline-buffer-file-name-style 'truncate-with-project)
    (doom-modeline-buffer-encoding nil)
    :config
    ;; do not display the host name, it's often too long.
    (doom-modeline-def-segment remote-host-no-host
      "Hostname for remote buffers."
      (when default-directory
        (when (file-remote-p default-directory 'host)
          (propertize
           " @"
           'face (if (doom-modeline--active)
                     'doom-modeline-host
                   'mode-line-inactive)))))
    (defvar popper-popup-status nil)
    (doom-modeline-def-segment popper-doom-modeline
      "modeline for popper"
      (when (or (eq popper-popup-status 'popup) (eq popper-popup-status 'user-popup))
        '(:eval (propertize " ^" 'face (if (doom-modeline--active)
                                           '(:inherit mode-line-emphasis)
                                         'mode-line-inactive)))))

    (doom-modeline-def-modeline 'main
      '(bar matches modals popper-doom-modeline workspace-name window-number buffer-info
                remote-host-no-host buffer-position word-count parrot selection-info)
      '(objed-state persp-name battery grip irc mu4e gnus github debug
                    input-method indent-info process vcs checker lsp misc-info))

    (doom-modeline-def-segment treemacs-doom-seg
      "modeline for treemacs"
      '(:eval (propertize " Treemacs" 'face (if (doom-modeline--active)
                                                '(:inherit doom-modeline-buffer-file :bold t)
                                              'mode-line-inactive))))

    (doom-modeline-def-modeline 'treemacs
      '(bar treemacs-doom-seg))

    ;; Frame-focus detection sometimes messes up. I probably don't need that
    ;; anyways.  Note that this seems to make multi-frame switching affect
    ;; doom-modeline-current-window, may need to reset it when focusing/unfocusing
    (advice-add #'doom-modeline-focus :override 'ignore)
    (advice-add #'doom-modeline-unfocus :override 'ignore)

    (advice-add 'jd:enable-graphic :after (lambda () (setq doom-modeline-icon t)))
    (advice-add 'jd:enable-terminal :after (lambda () (setq doom-modeline-icon nil)))

    (doom-modeline-mode))
#+end_src

*** Themes
I'm constantly changing themes as it turns out. I've been using Modus themes a lot recently.
#+begin_src elisp
  (use-package modus-themes
    :demand t
    :init
    ;; Add all your customizations prior to loading the themes
    (setq ;; modus-themes-prompts '(bold)
          modus-themes-slanted-constructs nil
          modus-themes-org-blocks 'gray-background
          modus-themes-common-palette-overrides
          '((fringe unspecified)
            ;; (bg-mode-line-inactive "#373737")
            ;; (fg-line-number-active fg-dim)
            ;; (fg-line-number-inactive bg-active)
            (bg-line-number-active unspecified)
            (bg-line-number-inactive unspecified)
            ;; code syntax:
            ;; (builtin magenta)
            ;; (comment yellow-faint)
            (constant magenta-cooler)
            ;; (docstring green-faint)
            ;; (docmarkup magenta-faint)
            ;; (fnname magenta-warmer)
            ;; (keyword cyan)
            ;; (preprocessor cyan-cooler)
            (string green-cooler)
            ;; (type magenta-cooler)
            ;; (variable blue-warmer)
            ;; (rx-construct magenta-warmer)
            ;; (rx-backslash blue-cooler)
            ))
    :config
    ;; Load the theme of your choice:
    (modus-themes-load-theme 'modus-vivendi) ;; OR (modus-themes-load-theme 'modus-operandi)

    (defun jd:reload-all-modeline ()
      (interactive)
      (when (featurep 'doom-modeline)
        (doom-modeline-mode -1)
        (doom-modeline-mode t))
      (when (and (featurep 'lsp-mode) lsp-headerline-breadcrumb-mode)
        (lsp-headerline--check-breadcrumb))
      (force-mode-line-update t))

    (add-hook 'modus-themes-after-load-theme-hook 'jd:reload-all-modeline)

    :bind ("<f5>" . modus-themes-toggle))
#+end_src

*** Font
The Fira font works very well both in terminal and in graphic Emacs.
#+begin_src elisp
  (add-to-list 'default-frame-alist '(font . "Fira Code-9.5"))
  (set-face-attribute 'variable-pitch nil :family "Fira Code")
  (set-face-attribute 'fixed-pitch nil :family "Fira Code")
#+end_src

*** Tabs
**** Tab bar
Tab bars are quite useful in Emacs to manage workspaces. But like tabs, I
find myself not using them very often. Using =C-x t= as the prefix:

#+begin_src elisp
  (use-package tab-bar
    :bind (("C-x t b" . tab-bar-switch-to-tab))
    :custom
    ((tab-bar-format '(tab-bar-format-history
                       tab-bar-format-tabs
                       tab-bar-separator
                       tab-bar-format-add-tab))
     (tab-bar-close-button-show t)
     (tab-bar-new-button-show t)
     (tab-bar-show nil))
    :config
    (tab-bar-mode 1))
#+end_src

#+begin_src elisp
  (use-package tab-bar-echo-area
    :config
    (tab-bar-echo-area-mode))
#+end_src
**** tab-line
#+begin_src elisp
  (use-package tab-line
    :config
    (global-tab-line-mode -1))
#+end_src

*** Others
Use a box for cursors. Just a personal preference.
#+begin_src elisp
  (setq-default cursor-type 'box)
  (setq-default cursor-in-non-selected-windows t)
#+end_src

Enable displaying time
#+begin_src elisp
  (setq display-time-default-load-average nil)
  (setq display-time-format " [%R]")
  (display-time-mode 1)
#+end_src

** Read-Completion
*** Vertico
#+begin_src elisp
  (use-package vertico
    :init
    (vertico-mode)
    (setq vertico-cycle t)
    (defvar jd--vertico-align-offset 0)
    :config
    (advice-add 'jd:enable-graphic :after (lambda () (setq jd--vertico-align-offset 0)))
    (advice-add 'jd:enable-terminal :after (lambda () (setq jd--vertico-align-offset 1)))
    (setq vertico-group-format
          (concat #("    " 0 4 (face vertico-group-separator))
                  #(" %s " 0 4 (face vertico-group-title))
                  #(" " 0 1 (face vertico-group-separator display
                                  (space :align-to (- right jd--vertico-align-offset)))))))
#+end_src

*** Consult
Useful functionalities for complete-read.
#+begin_src elisp
  (use-package consult
    ;; :straight (:build (:not compile))
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c m" . consult-mode-command)
           ("C-c o" . consult-outline)
           ("C-c i" . consult-imenu)
           ;; C-x bindings (ctl-x-map)
           ;; ("C-x M-:" . consult-complex-command)
           ("C-x b" . consult-buffer)
           ("C-x 4 b" . consult-buffer-other-window)
           ("C-x 5 b" . consult-buffer-other-frame)
           ("C-x r x" . consult-register)
           ("C-x r b" . consult-bookmark)
           ;; M-g bindings (goto-map)
           ("M-g g" . consult-goto-line)
           ("M-g M-g" . consult-goto-line)
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g f" . consult-flymake)
           ;; M-s bindings (search-map)
           ("M-s g" . consult-ripgrep)      ;; Alternatives: consult-grep, consult-ripgrep
           ("M-s f" . consult-find)          ;; Alternatives: consult-locate, my-fdfind
           ("M-s l" . consult-line)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Other bindings
           ("M-y" . consult-yank-pop))
    :init
    (setq register-preview-delay 0
          register-preview-function #'consult-register-preview)
    :config
    (setq consult-preview-key "C-l")
    (setq consult-narrow-key "<")
    (add-to-list 'consult-buffer-filter "\\`\\*EGLOT.*\\*\\'")
    (add-to-list 'consult-buffer-filter "\\`\\*Async-native-compile-log\\*\\'")
    (add-to-list 'consult-buffer-filter "\\`\\*Messages\\*\\'")
    (add-to-list 'consult-buffer-filter "\\`\\*Warnings\\*\\'")
    (defun jd:current-project-root ()
      (let ((p (project-current)))
        (if p
            (expand-file-name (project-root p)))))
    (setq consult-project-root-function #'jd:current-project-root)
    (when (>= emacs-major-version 27)
      (setq xref-show-definitions-function #'consult-xref))
    (setq xref-show-xrefs-function #'consult-xref)
    (setq-default completion-in-region-function 'consult-completion-in-region)
    (setq consult-imenu-config
        '((emacs-lisp-mode :toplevel "Functions" :types
                           ((102 "Functions" font-lock-function-name-face)
                            (109 "Macros" font-lock-function-name-face)
                            (112 "Packages" font-lock-constant-face)
                            (116 "Types" font-lock-type-face)
                            (118 "Variables" font-lock-variable-name-face)))
          (prog-mode :types
                     ((?f "Function")
                      (?c "Class")
                      (?F "Field")
                      (?v "Variable")
                      (?m "Method")
                      (?p "Property")
                      (?n "Namespace")
                      (?C "Constructor"))))))
#+end_src

*** Marginalia
Add annotations to minibuffer completions.
#+begin_src elisp
  (use-package marginalia
    :bind (:map minibuffer-local-map
                ("C-M-a" . marginalia-cycle))
    :init
    (marginalia-mode)
    (setq marginalia-annotators '(marginalia-annotators-light marginalia-annotators-heavy)))
#+end_src

*** embark
Enables useful actions to minibuffer completions.
#+begin_src elisp
  (use-package embark-consult
    :after (consult))
  
  (use-package embark
    :custom
    (embark-indicators '(embark-minimal-indicator))
    :bind
    ("C-o" . embark-act))
#+end_src

*** Orderless
#+begin_src elisp
  ;; Use the `orderless' completion style.
  ;; Enable `partial-completion' for files to allow path expansion.
  ;; You may prefer to use `initials' instead of `partial-completion'.
  (use-package orderless
    :init
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles . (basic partial-completion)))
                                          (eglot (styles . (orderless)))))
    (setq orderless-matching-styles '(orderless-literal orderless-regexp))
    (with-eval-after-load 'company
      (defun just-one-face (fn &rest args)
        (let ((orderless-match-faces [completions-common-part]))
          (apply fn args)))

      (advice-add 'company-capf--candidates :around #'just-one-face)))
#+end_src

** Projects

*** Project.el
#+begin_src elisp
  (use-package project
    :commands
    (project-switch-project
     project-find-file
     project-find-regexp
     project-find-dir
     project-vc-dir
     project-shell
     project-compile
     project-shell-command
     project-async-shell-command
     project-dired
     project-switch-to-buffer
     project-kill-buffers)
    :config
    (when (boundp 'project-prefix-map)
      (define-key project-prefix-map "m" #'magit-project-status)
      (add-to-list 'project-switch-commands '(magit-project-status "Magit") t)))
#+end_src
*** Ripgrep
Ripgrep is very fast and convenient when searching in a project.
#+begin_src elisp
  (use-package ripgrep)
#+end_src

*** Treemacs
Side bar to navigate files in a project. Quite helpful at times, and
looks modern.  It might conflict with other window management
packages, so need to be careful in config.
#+begin_src elisp
  (use-package treemacs
    :commands treemacs
    :custom
    ((treemacs-width 34)
     (treemacs-no-delete-other-windows t)
     (treemacs-width-is-initially-locked t)
     (treemacs-space-between-root-nodes nil))
    :custom-face
    (treemacs-root-face ((t (:inherit font-lock-string-face :weight bold :height 1.1))))
    :config
    (if (featurep 'doom-modeline)
        (setq treemacs-user-mode-line-format
              '("%e" (:eval (doom-modeline-format--treemacs))))
      (setq treemacs-user-mode-line-format
            "treemacs"))
    (treemacs-resize-icons 20)
    (use-package treemacs-magit))

#+end_src

** Version Control
Use =magit= for version control (of course).

*** Magit
#+begin_src elisp
  (use-package transient
    :custom
    ((transient-display-buffer-action '(display-buffer-below-selected))
     (transient-mode-line-format '("%e" mode-line-front-space mode-line-buffer-identification))
     (transient-show-popup 0.2)))
#+end_src
Customize Magit a bit to my liking.
#+begin_src elisp
  (use-package magit
    :init
    (setq magit-version "tmp")
    :bind
    ("C-x g" . magit-status)
    :custom
    ((ediff-diff-options "-w")
     (ediff-split-window-function #'split-window-horizontally)
     (ediff-window-setup-function #'ediff-setup-windows-plain)
     (magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)))
#+end_src

Magit-extras. Currently only using it for project.el.
#+begin_src elisp
  (use-package magit-extras
    :straight (magit)
    :commands (magit-project-status))
#+end_src

*** Git gutter
Subtly show diff info on the margin. Works with both terminal and graphic Emacs.
Not enabled globally as for tramp it works very slowly.
#+begin_src elisp
  (use-package git-gutter
    :commands
    (global-git-gutter-mode git-gutter-mode))
#+end_src

** Editing
*** Yasnippet - might need some autoloading optimization
Useful snippets. Also helps with company mode completion.
#+begin_src elisp
  (use-package yasnippet
    :config
    (yas-global-mode t))
#+end_src

*** Corfu
Trying out corfu to see how it works.
#+begin_src elisp
  (use-package corfu
    :demand t
    :custom
    ((corfu-cycle t)
     (corfu-auto t)
     (corfu-auto-delay 0.5)
     (corfu-auto-prefix 2)
     (corfu-preview-current nil)
     (corfu-scroll-margin 4)
     (corfu-bar-width 1)
     (corfu-min-width 50)
     (corfu-max-width 120))
    :bind
    (("C-<tab>" . completion-at-point))
    :init
    (defun jd:disable-corfu-auto ()
      (setq-local corfu-auto nil))
    :hook
    ((gud-mode . jd:disable-corfu-auto))
    :config
    (global-corfu-mode)
    (defvar corfu-max-suffix-width 14)
    (defun jd:corfu--format-candidates (cands)
      "Format annotated CANDS."
      (setq cands
            (cl-loop for c in cands collect
                     (cl-loop for s in c collect
                              (replace-regexp-in-string "[ \t]*\n[ \t]*" " " s))))
      (let ((width 0)
            (pw 0)
            (cw 0)
            (sw 0)
            ;; -4 because of margins and some additional safety
            (max-width (min corfu-max-width (- (frame-width) 4))))
        (cl-loop for (cand prefix suffix) in cands do
                 (setq pw (max pw (string-width prefix)))
                 (setq sw (max sw (string-width suffix)))
                 (setq cw (max cw (string-width cand))))
        (setq width (+ pw sw cw))
        (when (> width max-width)
          (setq width max-width))
        (when (< width corfu-min-width)
          (setq width corfu-min-width))
        (list pw width
              (cl-loop for (cand prefix suffix) in cands collect
                       (progn
                         (when (> (+ (string-width cand) (string-width prefix) (string-width suffix)) width)
                           (setq suffix (truncate-string-to-width suffix corfu-max-suffix-width)))
                         (when (> (+ (string-width cand) (string-width prefix) (string-width suffix)) width)
                           (setq cand (concat
                                       (truncate-string-to-width cand (- width pw (string-width suffix) 2))
                                       "..")))
                         (truncate-string-to-width
                          (concat prefix
                                  (make-string (max 0 (- pw (string-width prefix))) ?\s)
                                  cand
                                  (make-string
                                   (- width (+ pw (string-width cand) (string-width suffix)))
                                   ?\s)
                                  suffix)
                          width))))))
    (advice-add 'corfu--format-candidates :override #'jd:corfu--format-candidates))
#+end_src

Cape.
#+begin_src elisp
  (use-package cape
    :init
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-keyword))
#+end_src

Kind-icons
#+begin_src elisp
  (use-package kind-icon
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
    (kind-icon-default-style '(:padding -1 :stroke 0 :margin 0 :radius 0 :scale 0.9 :height 0.6))
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

Terminal corfu popup
#+begin_src elisp
  (use-package popon
    :straight (:type git :repo "https://codeberg.org/akib/emacs-popon.git"))

  (use-package corfu-terminal
    :after corfu
    :straight (:type git :repo "https://codeberg.org/akib/emacs-corfu-terminal.git")
    :config
    (defun advice-corfu--format-candidates (orig-fn cands)
      (let ((corfu-max-width 120))
        (when corfu-terminal-mode
          (setq corfu-max-width (min (- (window-max-chars-per-line) 1) corfu-max-width)))
        (funcall orig-fn cands)))

    (advice-add 'jd:disable-terminal :after
                (lambda ()
                    (advice-remove 'corfu--format-candidates #'advice-corfu--format-candidates)
                    (corfu-terminal-mode -1)))

    (advice-add 'jd:enable-terminal :after
                (lambda ()
                    (advice-add 'corfu--format-candidates :around #'advice-corfu--format-candidates)
                    (corfu-terminal-mode t))))
#+end_src

*** Flymake popon
#+begin_src elisp
  (use-package flymake-popon
    :straight (:type git :repo "https://codeberg.org/akib/emacs-flymake-popon.git")
    :commands (flymake-popon-mode global-flymake-popon-mode))
#+end_src

*** Spell Check

**** Jinx
Trying out jinx.
#+begin_src elisp
  (use-package jinx)
#+end_src

*** Undo
Going back to =Undo-tree=.
#+begin_src elisp
  (use-package undo-tree
    :init
    ;; Define a version that does not display any message when saving
    (defun jd:undo-tree-save-history (orig-func &rest args)
      (let ((message-log-max nil)
            (inhibit-message t))
        (apply orig-func args)))
    :custom
    (undo-tree-incompatible-major-modes '(term-mode special-mode))
    (undo-tree-history-directory-alist '(("." . (concat (getenv "HOME") "/undotree-hist/"))))
    :config
    (advice-add 'undo-tree-save-history :around 'jd:undo-tree-save-history)
    (global-undo-tree-mode))
#+end_src

*** Smartparens - try other packages and optimize
Automatically highlights and inserts parens. Add support for curly
braces (automatically add a newline there) and c comment pairs.

#+begin_src elisp
  (use-package smartparens
    :config
    (sp-with-modes
        '(c-mode c++-mode)
      (sp-local-pair "{" nil
                     :post-handlers '(("||\n[i]" "RET")))
      (sp-local-pair "/*" "*/"))

    (sp-with-modes sp--lisp-modes
      ;; disable ', it's the quote character!
      (sp-local-pair "'" nil :actions nil)
      ;; also only use the pseudo-quote inside strings where it serve as
      ;; hyperlink.
      (sp-local-pair "`" "'" :when '(sp-in-string-p sp-in-comment-p))
      (sp-local-pair "`" nil
                     :skip-match (lambda (ms mb me)
                                   (cond
                                    ((equal ms "'")
                                     (or (sp--org-skip-markup ms mb me)
                                         (not (sp-point-in-string-or-comment))))
                                    (t (not (sp-point-in-string-or-comment)))))))

    (show-paren-mode -1)
    (smartparens-global-mode t)
    (show-smartparens-global-mode t))
#+end_src

*** Multiple cursors
#+begin_src elisp
  (use-package multiple-cursors
    :bind
    (("C-S-c C-S-c" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)
     ("C-c C-<" . mc/mark-all-like-this)))
#+end_src

*** Others
Set the fill column width to be 80 for the general case.
#+begin_src elisp
  (setq-default fill-column 80)
  (setq column-number-mode t)
#+end_src

** EAF
EAF feels promising, but I don't particularly like it because it constantly
flickers when I resize windows, and it does not just work without all these
dependencies. Only load it if needed.
#+begin_src elisp
  (defun jd:load-eaf ()
    (interactive)
    (use-package epc)
    (use-package eaf
      :straight (:files
                 (:defaults "eaf.py" "setup.py" "core" "app" "docker" "install-eaf.sh")
                 :no-byte-compile t)))
#+end_src

** Latex & markdown
Use =auctex=.
#+begin_src elisp
  (use-package auctex
    :no-require
    :hook
    (tex-mode . TeX-mode)
    (TeX-mode . TeX-source-correlate-mode))
#+end_src

#+begin_src elisp
  (use-package markdown-mode
    :commands markdown-mode
    :magic ("%MD" . markdown-mode))
#+end_src

** PDF

*** COMMENT PDF with image roll
Dalanicolai has contributed a continuous pdf tools fork, with a package
image-roll.  Using the code from github right now. May need to update later if
it is pushed to Melpa / pdf-tools.
#+begin_src elisp
  (use-package image-roll
    :after pdf-tools
    :straight (:type git :host github :repo "dalanicolai/image-roll.el"))
  (use-package pdf-tools
    :straight (:type git :host github :repo "dalanicolai/pdf-tools" :branch "pdf-roll"
                     :files ("lisp/*.el"
                             "README"
                             ("build" "Makefile")
                             ("build" "server")
                             (:exclude "lisp/tablist.el" "lisp/tablist-filter.el")))
    :magic ("%PDF" . pdf-view-mode)
    :config
    (setq pdf-view-use-scaling t)
    (pdf-tools-install :no-query))
#+end_src

*** Normal pdf tools
#+begin_src elisp
  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :config
    (setq pdf-view-use-scaling t)
    (pdf-tools-install :no-query))
#+end_src

*** Other pdf related
Use org-pdftools for links etc.
#+begin_src elisp
  (use-package org-pdftools
    :after (org pdf-tools)
    :hook (org-mode . org-pdftools-setup-link))
#+end_src

** Org-mode
I am quite new to org mode, but there are some things already quite useful.

*** Install org-mode
Emacs comes with a default yet quite old version of org. Install the new one.
=straight.el= helps with installing it at the first time.

#+begin_src elisp
  (use-package org
    :commands
    (org-mode org-agenda org-store-link)
    :mode
    (("\\.org_archive\\'" . org-mode)
     ("\\.org\\'" . org-mode))
    :custom
    (org-return-follows-link nil)
    (org-imenu-depth 4)
    (org-startup-indented t)
    (org-agenda-restore-windows-after-quit t)
    (org-cycle-include-plain-lists 'integrate)
    (org-latex-create-formula-image-program 'dvisvgm)
    (org-cite-global-bibliography '("~/bib/references.bib"))
    :config
    (require 'org-tempo)
    (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.6))
    (setq org-todo-keywords
          '((sequence "TODO" "DOING" "WAITING" "|" "DONE" "ABANDONED")))
    (setf (cdr (assoc 'file org-link-frame-setup)) 'find-file))
#+end_src

Change the org files here if needed.
#+begin_src elisp
  (setq org-agenda-files '("~/MyOrgNotes/agenda.org"
                           "~/MyOrgNotes/emacs_todos.org"))
#+end_src

*** TOC
Auto insert a TOC when saving. Very helpful for GitHub org files.
#+begin_src elisp
  (use-package toc-org
    :after org
    :hook
    (org-mode . toc-org-mode))
#+end_src

*** Org modern
Beautify the bullets.

#+begin_src elisp
  (use-package org-modern
    :after org
    :commands
    (org-modern-mode org-modern-agenda)
    :config
    (advice-add 'jd:enable-graphic :after
                (lambda ()
                  (add-hook 'org-mode-hook 'org-modern-mode)
                  (add-hook 'org-agenda-finalize-hook 'org-modern-agenda)))
    (advice-add 'jd:disable-graphic :after
                (lambda ()
                  (remove-hook 'org-mode-hook 'org-modern-mode)
                  (remove-hook 'org-agenda-finalize-hook 'org-modern-agenda))))
#+end_src

*** Citar
Manage citations with citar
#+begin_src elisp
  (use-package citar
    :no-require
    :custom
    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-bibliography org-cite-global-bibliography)
    ;; optional: org-cite-insert is also bound to C-c C-x C-@
    :bind
    (:map org-mode-map :package org ("C-c b" . #'org-cite-insert))
    :config
    (defun jd:citar-create-roam-node (keys &optional arg)
      "Insert citation for the KEYS and create a org roam node.

  Prefix ARG is passed to the mode-specific insertion function. It
  should invert the default behaviour for that mode with respect to
  citation styles. See specific functions for more detail."
      (interactive
       (if (citar--get-major-mode-function 'insert-citation)
           (list (citar-select-refs) current-prefix-arg)
         (error "Citation insertion is not supported for %s" major-mode)))

      (dolist (key keys)
        (jd:create-roam-citation-node key)))

    (defun jd:create-roam-citation-node (key)
      (let* ((key-entry (citar-get-entry key))
             (title
              (cond (key-entry                   
                     (citar-format--entry "${author editor} :: ${title}" (cdr key-entry)))
                    (t
                     (error "Cannot find citation with key")))))
        (org-roam-capture- :templates
                           '(("d" "default" plain "%?" :if-new
                              (file+head "${citekey}.org"
                                         ":PROPERTIES:
  :ROAM_REFS: [cite:@${citekey}]
  :END:
  ,#+title: ${title}\n")
                              :immediate-finish t
                              :unnarrowed t))
                           :info (list :citekey key)
                           :node (org-roam-node-create :title title)
                           :props '(:finalize find-file))))

    (defun jd:create-roam-citation-node-at-point()
      (interactive)
      (cond
       ((derived-mode-p 'org-mode)
        (let* ((element (org-element-context))
               (type (org-element-type element))
               (citekey
                (cond
                 ((eq type 'citation)
                  (org-element-property
                   :key (car (org-cite-get-references element))))
                 ((eq type 'citation-reference)
                  (org-element-property :key element))
                 (around-point
                  (user-error "Cursor not in an Org-cite element"))
                 (t
                  (user-error "Invalid optional argument ELEMENT: %s.  Org-cite\
    citation or reference expected" element)))))
          (jd:create-roam-citation-node citekey)))
       (t
        (user-error "This function works only in Org mode")))))
#+end_src

*** Org roam
Trying this out!
#+begin_src elisp
  (use-package org-roam
    :init
    (defun jd:org-roam-follow-citation()
      (interactive)
      (cond
       ((derived-mode-p 'org-mode)
        (let* ((element (org-element-context))
               (type (org-element-type element))
               (citekey
                (cond
                 ((eq type 'citation)
                  (org-element-property
                   :key (car (org-cite-get-references element))))
                 ((eq type 'citation-reference)
                  (org-element-property :key element))
                 (around-point
                  (user-error "Cursor not in an Org-cite element"))
                 (t
                  (user-error "Invalid optional argument ELEMENT: %s.  Org-cite\
    citation or reference expected" element))))
               (node (org-roam-node-from-ref (concat "@" citekey))))
          (if node
              (org-roam-node-visit node)
            (user-error "No node found for the cite key,
  call jd:create-roam-citation-node-at-point to create the node."))))
       (t
        (user-error "This function works only in Org mode"))))

    (defun jd:follow-cite(datum arg)
      (funcall-interactively 'jd:org-roam-follow-citation))

    (advice-add 'org-cite-follow :override #'jd:follow-cite)

    :commands (jd:org-roam-follow-citation org-roam-node-from-ref)
    :config
    (defalias 'org-font-lock-ensure 'font-lock-ensure)
    (setq org-roam-directory (file-truename "~/org-roam"))
    (org-roam-db-autosync-enable))

  (use-package org-roam-ui
    :after org-roam)
#+end_src

** Programming
Setups for programming tools.
*** Xref setup
=xref= is the built-in functionality that Emacs uses. I have a few tweaks to
make it work better with my work flow.

First, define a custom function that allows opening the definition at other
window with a prefix argument.
#+begin_src elisp
  (defun jd:xref-find-definitions (arg)
    "Custom function to find definitions in other window with ARG is non nil."
    (interactive "P")
    (let ((current-prefix-arg nil)
          (xref-prompt-for-identifier nil))
      (if arg
          (call-interactively 'xref-find-definitions-other-window)
        (call-interactively 'xref-find-definitions))))
#+end_src

Similarly, define a custom function that do not prompt the user when the
find reference function has only just one result.
#+begin_src elisp
  (defun jd:xref-find-references (arg)
    "Find references with no prefix arg."
    (interactive "p")
    (let ((current-prefix-arg nil)
          (xref-prompt-for-identifier (> arg 1)))
      (call-interactively 'xref-find-references)))
#+end_src

By default, xref has a marker ring that allows users to trace back. Add a
new marker ring here to allow tracing forward after going back (like a
redo).
#+begin_src elisp
  
#+end_src

Finally set up xref with the above tweaks. The key mappings are a bit
different with the default ones.
#+begin_src elisp
  (ironkey-mode -1)
  (use-package xref
    :demand t
    :bind
    (("M-." . jd:xref-find-definitions)
     ("M-," . jd:xref-find-references))
    :config

    (advice-add 'jd:enable-terminal :after
                (lambda ()
                  (advice-add 'xref-pulse-momentarily :override #'ignore)))
    (advice-add 'jd:disable-terminal :after
                (lambda ()
                  (advice-remove 'xref-pulse-momentarily #'ignore)))

    (if (>= emacs-major-version 29)
        (progn
          (define-key global-map (kbd "C-,") 'xref-go-back)
          (define-key global-map (kbd "C-.") 'xref-go-forward))
      (defvar jd--xref-forward-marker-ring)
      (setq jd--xref-forward-marker-ring (make-ring xref-marker-ring-length))

      (defun jd:xref-clear-fwd-marker-ring ()
        "Clear the forward marker ring for xref."
        (when (not (ring-empty-p jd--xref-forward-marker-ring))
          (setq jd--xref-forward-marker-ring (make-ring xref-marker-ring-length))))

      (defun jd:xref-pop-marker-stack ()
        "Pop a marker from xref marker ring, and save it in the forward marker ring."
        (interactive)
        (let ((ring xref--marker-ring))
          (when (ring-empty-p ring)
            (user-error "Marker stack is empty"))
          (let ((marker (ring-remove ring 0)))
            (ring-insert jd--xref-forward-marker-ring (point-marker))
            (switch-to-buffer (or (marker-buffer marker)
                                  (user-error "The marked buffer as been deleted")))
            (goto-char (marker-position marker))
            (set-marker marker nil nil)
            (run-hooks 'xref-after-return-hook))))

      (defun jd:xref-pop-fwd-marker-stack ()
        "Pop the marker from the xref fwd marker stack, and save in the xref marker ring."
        (interactive)
        (let ((ring jd--xref-forward-marker-ring))
          (when (ring-empty-p ring)
            (user-error "Forward marker stack is empty"))
          (let ((marker (ring-remove ring 0)))
            (ring-insert xref--marker-ring (point-marker))
            (switch-to-buffer (or (marker-buffer marker)
                                  (user-error "The marked buffer as been deleted")))
            (goto-char (marker-position marker))
            (set-marker marker nil nil)
            (run-hooks 'xref-after-return-hook))))
      (advice-add 'xref-pop-marker-stack :override #'jd:xref-pop-marker-stack)
      (advice-add 'xref-push-marker-stack :before #'jd:xref-clear-fwd-marker-ring)

      (define-key global-map (kbd "C-,") 'xref-pop-marker-stack)
      (define-key global-map (kbd "C-.") 'jd:xref-pop-fwd-marker-stack)))
  (ironkey-mode 1)
#+end_src

*** eldoc
Set up eldoc so it does not automatically use the echo buffer, but only do so
when asked.

#+begin_src elisp
  (use-package eldoc
    :straight (:type built-in)
    :custom
    ((eldoc-idle-delay 0.2)
     (eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
     ;; (eldoc-echo-area-use-multiline-p t)
     ;; (eldoc-echo-area-display-truncation-message nil)
     )
    :bind
    ("C-c h" . eldoc)
    :demand t)
#+end_src

*** Eglot
=eglot= is an LSP client that uses mostly built-in Emacs functionalities.
It is much easier to manage than =lsp-mode= and more light-weight.
#+begin_src elisp
  (use-package eglot
    :straight (:type built-in)
    :custom
    ((eglot-send-changes-idle-time 0.5)
     (eglot-sync-connect t))
    :hook
    ((c-mode . eglot-ensure)
     (c++-mode . eglot-ensure)
     (eglot-managed-mode . (lambda ()
                             (when (not jd:code-reading--enabled)
                               (eglot-inlay-hints-mode -1)))))
    :config
    (add-to-list 'eglot-server-programs
                 '((c-mode c++-mode c-ts-mode c++-ts-mode) .
                   ("clangd-15"
                    "--limit-results=200"
                    "--header-insertion=never"
                    "--header-insertion-decorators=0"
                    "--clang-tidy"
                    "--completion-style=detailed"
                    "--enable-config"
                    "-j=8"
                    "--pch-storage=memory")))
    (setq eglot-stay-out-of '(eldoc-documentation-strategy)))
#+end_src

#+begin_src elisp
  (use-package consult-eglot
    :if (featurep 'consult))
#+end_src

*** COMMENT lsp-mode
#+begin_src elisp
  (use-package flymake)
  (setenv "LSP_USE_PLISTS" "true")
  (use-package lsp-mode
    :init
    (setq lsp-auto-configure t)
    ;; really make sure to use plists...
    (defvar lsp-use-plists t)
    (setq lsp-use-plists t)
    (setq lsp-clients-clangd-executable "clangd-15")
    (setq lsp-keymap-prefix "C-c l")
    :hook
    ((c-mode . lsp)
     (c++-mode . lsp)
     (lsp-mode . lsp-enable-which-key-integration))
    :config
    (setq lsp-idle-delay 0.1)
    (setq lsp-modeline-diagnostics-enable nil) ;; we have flymake to show errors
    (setq lsp-modeline-code-actions-enable t)
    (setq lsp-modeline-code-actions-segments '(count name))
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-headerline-breadcrumb-enable-diagnostics nil)

    (advice-add 'jd:enable-terminal :after
                (lambda ()
                  (setq lsp-headerline-breadcrumb-icons-enable nil)))
    (advice-add 'jd:enable-graphic :after
                (lambda ()
                  (setq lsp-headerline-breadcrumb-icons-enable t)))

    (setq lsp-clients-clangd-args '("--header-insertion-decorators=0"
                                    "--limit-results=200"))
    (setq lsp--highlight-kind-face '((1 . bold)
                                     (2 . bold)
                                     (3 . bold)))
    (setq lsp-completion-provider :none)
    (defun corfu-lsp-setup ()
      (setq-local completion-styles '(orderless)
                  completion-category-defaults nil))
    (add-hook 'lsp-completion-mode-hook #'corfu-lsp-setup)

    (setq lsp-semantic-token-faces '(("comment" . lsp-face-semhl-comment)))
    (setq lsp-semantic-token-modifier-faces '(()))
    (setq lsp-semantic-tokens-set-comment-syntax nil)
    (setq lsp-semantic-tokens-enable t)

    (use-package lsp-ui
      :config
      (setq lsp-ui-doc-show-with-cursor nil)
      (setq lsp-ui-doc-show-with-mouse nil)
      (setq lsp-ui-doc-enable nil))

    ;; (use-package lsp-pyright)
    (setq lsp-pylsp-plugins-autopep8-enabled t)

    (use-package lsp-treemacs))
#+end_src

#+begin_src elisp
  (use-package consult-lsp
    :if (featurep 'consult))
#+end_src

*** Compiling
#+begin_src elisp
  (setq compilation-scroll-output 'first-error)
  (setq compilation-auto-jump-to-first-error t)
  (setq compilation-skip-threshold 1)
#+end_src

Define a function to auto-close compilation window if compilation is successful.
#+begin_src elisp
  (defcustom jd--compile-autoclose-time 1 "Seconds to wait before auto close the compilation buffer.")
  (defun jd:compile-auto-close (buffer string)
    "Hook to auto close compilation BUFFER. STRING is the returned message."
    (cond ((and (string-match "finished" string) (string-equal (buffer-name) "*compilation*"))
           (message "Build may be successful: closing window.")
           (run-with-timer jd--compile-autoclose-time nil 'delete-window (get-buffer-window buffer t)))
          (t (message "Compilation exited abnormally: %s" (string-trim string)))))

  ;; (push 'jd:compile-auto-close compilation-finish-functions)
#+end_src

Define a function to toggle the skip threshold of compilation buffer:
#+begin_src elisp
  (defun jd:toggle-compile-skip-thresh()
    "Toggle the compilation skip threshold."
    (interactive)
    (if (eq compilation-skip-threshold 1)
        (progn (setq compilation-skip-threshold 2)
               (message "Skip threshold set to errors"))
      (progn (setq compilation-skip-threshold 1)
             (message "Skip threshold set to warnings"))))
#+end_src

Support xterm coloring in compilation buffers:
#+begin_src elisp
  (require 'ansi-color)
  (defun jd:colorize-compilation-buffer ()
    (read-only-mode -1)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (read-only-mode t))
  (add-hook 'compilation-filter-hook 'jd:colorize-compilation-buffer)
#+end_src

*** C/C++ programming
Clangd language server is used with =eglot= for C programming.

**** Clang-format
Set up clang format so it auto-formats on save, but only for c mode.
This is not needed with =lsp-mode= or =eglot=.

#+begin_src elisp
  (use-package clang-format
    :custom
    ((clang-format-style "file")
     (clang-format-executable "clang-format")))
#+end_src

**** Others
Prefer using =//= instead of =/* */=.
#+begin_src elisp
  (add-hook 'c-mode-common-hook (lambda ()
                                  (c-toggle-comment-style -1)))
#+end_src

Use cmake-mode
#+begin_src elisp
  (use-package cmake-mode)
#+end_src

*** GDB set up
Use GDB many windows. But do not pop-up.
#+begin_src elisp
  (use-package gdb-mi
    :commands
    (gdb)
    :custom
    ((gdb-display-io-nopopup t)
     (gdb-many-windows t)
     (gdb-restore-window-configuration-after-quit t)))
#+end_src

*** Reading Mode
A simple function that toggles a bunch of infomation shown in the code.
#+begin_src elisp
  (defvar jd:code-reading--enabled nil)

  (defun jd:code-reading--enable-global ()
    (when eldoc--doc-buffer
      (display-buffer eldoc--doc-buffer)))

  (defun jd:code-reading--enable-local ()
    (when eglot--managed-mode
      (eglot-inlay-hints-mode t)))

  (defun jd:code-reading--disable-global ()
    (when (get-buffer-window eldoc--doc-buffer)
      (delete-window (get-buffer-window eldoc--doc-buffer))))

  (defun jd:code-reading--disable-local ()
    (when eglot--managed-mode
      (eglot-inlay-hints-mode -1)))

  (defun jd:code-reading-toggle ()
    (interactive)
    (if jd:code-reading--enabled
        (progn
          (setq jd:code-reading--enabled nil)
          (jd:code-reading--disable-global)
          (remove-hook 'prog-mode-hook 'jd:code-reading--enable-local)
          (let ((buffers (buffer-list)))
            (while buffers
              (with-current-buffer (car buffers) (jd:code-reading--disable-local))
              (setq buffers (cdr buffers)))))
      (setq jd:code-reading--enabled t)
      (jd:code-reading--enable-global)
      (add-hook 'prog-mode-hook 'jd:code-reading--enable-local)
      (let ((buffers (buffer-list)))
        (while buffers
          (with-current-buffer (car buffers) (jd:code-reading--enable-local))
          (setq buffers (cdr buffers))))))

  (define-key global-map (kbd "C-c r") 'jd:code-reading-toggle)
#+end_src

*** Others
Display line number mode for programming. This is in conflict with company
mode in terminals. Disabled for now.
#+begin_src elisp
  (use-package display-line-numbers
    :demand t
    :custom
    (display-line-numbers-width 4)
    :hook
    (prog-mode . display-line-numbers-mode))
#+end_src

Display the current function name.

#+begin_src elisp
  (defun jd:display-which-func ()
    (interactive)
    (message (which-function)))
  (use-package which-func
    :demand t
    :bind
    (("C-c f" . jd:display-which-func)))
#+end_src

Display the flymake fringe indicators on the right.
#+begin_src elisp
  (setq flymake-fringe-indicator-position 'right-fringe)
  (setq flymake-no-changes-timeout 0.2)
#+end_src

Topsy displays the current function in the header-line
#+begin_src elisp
  (use-package topsy
    :commands
    (topsy-mode))
#+end_src

** Terminal/Shell
=vterm= emulates the terminal well and enables many Emacs key-bindings
as a buffer.
#+begin_src elisp
  (use-package vterm
    :commands vterm
    :if module-file-suffix
    :init
    (defun jd:vterm-yank-pop-action (orig-fun &rest args)
      (interactive "p")
      (if (equal major-mode 'vterm-mode)
          (let ((inhibit-read-only t)
                (yank-undo-function (lambda (_start _end) (vterm-undo))))
            (cl-letf (((symbol-function 'insert-for-yank)
                       (lambda (str) (vterm-send-string str t))))
              (apply orig-fun args)))
        (apply orig-fun args)))
    :custom
    ((vterm-kill-buffer-on-exit t)
     (vterm-timer-delay 0.01)
     (vterm-min-window-width 100)
     (vterm-max-scrollback 10000)
     (vterm-enable-manipulate-selection-data-by-osc52 t)
     (vterm-keymap-exceptions '("M-`" "C-c" "C-x" "C-u" "C-g" "C-h" "C-l" "M-x" "M-o" "C-y" "M-y"))
     (vterm-shell "zsh"))
    :config
    (advice-add 'consult-yank-pop :around #'jd:vterm-yank-pop-action))
#+end_src

** TTY Emacs Specific
*** Mouse
In TTY Emacs, I still want to use mouse sometimes.
#+begin_src elisp
  (advice-add 'jd:enable-terminal :after
              (lambda ()
                "mouse."
                (xterm-mouse-mode t)))
  (advice-add 'jd:enable-graphic :after
              (lambda ()
                (xterm-mouse-mode -1)))
  (setq xterm-set-window-title nil)
#+end_src

*** Clipetty
=clipetty= helps transferring the paste board from a TTY Emacs to a
remote client.
#+begin_src elisp
  (use-package clipetty
    :demand t
    :config
    (global-clipetty-mode))
#+end_src

*** Vertical splitter
Use full-height.
#+begin_src elisp
  (defun jd:change-window-divider ()
    (let ((display-table (or buffer-display-table standard-display-table (make-display-table))))
        (set-display-table-slot display-table 5 ?│)
        (set-window-display-table (selected-window) display-table)))

  (add-hook 'window-configuration-change-hook 'jd:change-window-divider)
#+end_src

** Buffer/Window Management
*** =ace-window=
Jumping among windows.
#+begin_src elisp
  (use-package ace-window
    :bind
    ("M-o" . ace-window))
#+end_src

*** Window movements
Use Shift + arrows to move among windows.
#+begin_src elisp
  (windmove-default-keybindings)
#+end_src
    
*** Side windows
Define the rules for side windows.

Allow fit window to buffer horizontally. Also resize pixel-wise.
#+begin_src elisp
  (setq window-resize-pixelwise t)
#+end_src

Let vertical side windows take full height.
#+begin_src elisp
  (setq window-sides-vertical t)
#+end_src

Define the function to fit buffer width with constraints.
#+begin_src elisp
  (defcustom jd--fit-min-ratio 0.2 "Minimum width of a window to fit to buffer.")
  (defcustom jd--fit-max-ratio 0.3 "Maximum width of a window to fit to buffer.")

  (defun jd:fit-window-to-buffer-ratio-hor (&optional window)
    "Fit WINDOW to buffer with ratio constraints."
    (let ((min-width (ceiling (* (frame-width) jd--fit-min-ratio)))
          (max-width (floor (* (frame-width) jd--fit-max-ratio)))
          (fit-window-to-buffer-horizontally t))
      (fit-window-to-buffer window nil nil max-width min-width nil)))

  (defun jd:fit-window-to-buffer-ratio-ver (&optional window)
    "Fit WINDOW to buffer with ratio constraints."
    (let ((min-hgt (ceiling (* (frame-height) jd--fit-min-ratio)))
          (max-hgt (floor (* (frame-height) jd--fit-max-ratio))))
      (fit-window-to-buffer window max-hgt min-hgt nil nil nil)))
#+end_src

Define the variable to determine width with a fixed ratio. (Currently not used).
#+begin_src elisp
  (defcustom jd--fixed-width-ratio 0.4 "Fixed width ratio for sidewindows")
  (defcustom jd--fixed-hgt-ratio 0.3 "Fixed height ratio for sidewindows")
#+end_src

Set =display-buffer-alist= to display certain buffers in side windows.
#+begin_src elisp
  (defun jd:display-buffer-in-side-win-selected-tab (buffer alist)
    (let ((window (display-buffer-in-side-window buffer alist)))
      (select-window window)
      (tab-line-mode t)))

  (defun jd:display-buffer-in-side-win-selected (buffer alist)
    (let ((window (display-buffer-in-side-window buffer alist)))
      (select-window window)
      (tab-line-mode -1)))

  (setq display-buffer-alist
        `(("\\*\\(.*vterm.*\\|.*term.*\\|.*[Ss]hell.*\\)\\*"
           jd:display-buffer-in-side-win-selected
           (window-height . 0.4)
           (side . bottom)
           (slot . 0)
           (preserve-size . (nil . nil)))
          (".*\\*.*eldoc.*\\*"
           display-buffer-in-side-window
           (side . top)
           (slot . 0)
           (window-height . 0.25)
           (preserve-size . (nil . nil)))))
#+end_src

*** Popper.el
Displays pop-up buffers that can be toggled easily.
#+begin_src elisp
  (use-package popper
    :bind (("C-`"   . popper-toggle-latest)
           ("M-`"   . popper-cycle)
           ("C-M-`" . popper-toggle-type))
    :init
    (setq popper-reference-buffers
          '("term\\*"
            "shell"))
    (setq popper-mode-line "") ;; popper modeline is defined in doom modeline now
    (popper-mode +1)
    (popper-echo-mode +1)
    :config
    (setq popper-display-control nil))
#+end_src

** Miscellaneous Packages
*** Which-key mode
Displays the key bindings after a prefix.

#+begin_src elisp
  (use-package which-key
    :config
    (which-key-mode t)
    (setq which-key-popup-type 'minibuffer))
#+end_src

*** Sudo edit
Makes it easier to edit files that needs sudo.

#+begin_src elisp
  (use-package sudo-edit
    :commands (sudo-edit sudo-edit-find-file))
#+end_src

*** Pyim input method.
#+begin_src elisp
  (defvar jd--loaded-pyim-dict nil)

  (defun jd:pyim-basedict-enable ()
    "Add basedict to pyim."
    (interactive)
    (let* ((file (concat (file-name-directory
                          (straight--repos-dir "pyim-basedict"))
                         "pyim-basedict.pyim")))
      (when (file-exists-p file)
        (if (featurep 'pyim)
            (pyim-extra-dicts-add-dict
             `(:name "Basedict-elpa"
                     :file ,file
                     :coding utf-8-unix
                     :dict-type pinyin-dict
                     :elpa t))
          (message "pyim 没有安装，pyim-basedict 启用失败。")))))

  (defun jd:pyim-greatdict-enable ()
    "Add greatdict to pyim."
    (interactive)
    (let* ((file (concat (file-name-directory
                          (straight--repos-dir "pyim-greatdict"))
                         "pyim-greatdict.pyim.gz")))
      (when (file-exists-p file)
        (if (featurep 'pyim)
            (pyim-extra-dicts-add-dict
             `(:name "Greatdict-elpa"
                     :file ,file
                     :coding utf-8-unix
                     :dict-type pinyin-dict
                     :elpa t))
          (message "pyim 没有安装，pyim-greatdict 启用失败。")))))

  (use-package pyim
    :init
    (setq default-input-method "pyim")
    (defun jd:load-pyim-dict ()
      (interactive)
      (when (not jd--loaded-pyim-dict)
        (message "Loading pyim dictionaries...")
        (use-package pyim-basedict)
        (use-package pyim-greatdict
          :straight (:type git
                           :host github
                           :repo "tumashu/pyim-greatdict"))
        (setq jd--loaded-pyim-dict t)
        (message "Done.")))
    (advice-add 'jd:enable-graphic :after
                (lambda ()
                  (setq pyim-page-tooltip 'posframe)))
    (advice-add 'jd:enable-terminal :after
                (lambda ()
                  "pyim-pop"
                  (use-package popup)
                  (setq pyim-page-tooltip 'popon)))
    :commands
    (input-method-activate)
    :config
    (jd:load-pyim-dict)
    (jd:pyim-basedict-enable)
    (jd:pyim-greatdict-enable))
#+end_src

*** Burly bookmark management
#+begin_src elisp
  (use-package burly
    :bind (("C-c b f" . burly-bookmark-frames)
           ("C-c b o" . burly-open-bookmark)
           ("C-c b w" . burly-bookmark-windows))
    :config
    (bookmark-maybe-load-default-file)
    (burly-tabs-mode t))
#+end_src

*** Auth-sources
#+begin_src elisp
  (setq auth-sources '((:source "~/.authinfo.gpg")))
#+end_src

*** Restart emacs
Makes it much simpler to just restart emacs.
#+begin_src elisp
  (use-package restart-emacs
    :commands restart-emacs)
#+end_src

** Final Touch
*** Thresholds
Set gc thres back to a more normal value.
#+begin_src elisp
  (setq gc-cons-threshold (* 50 1024 1024))
  (setq garbage-collection-messages nil)
  (defvar jd--gc-done nil)
  (run-with-idle-timer 10 t (lambda ()
                              (when (not jd--gc-done)
                                (setq jd--gc-done t)
                                (garbage-collect))))
  (defun jd:set-gc-done ()
    (setq jd--gc-done nil))
  (add-hook 'pre-command-hook #'jd:set-gc-done)
#+end_src

*** Startup buffer
Do not show the startup buffer.
#+begin_src elisp
  (setq inhibit-startup-message t)
#+end_src

*** Set up server
#+begin_src elisp
  (jd:init-display-settings)
#+end_src

*** Treesit hacks
Now we have treesitter in emacs, we will use these modes when needed. But also add the hooks too.
#+begin_src elisp
  (use-package treesit-auto
    :disabled
    :straight (:type git
                     :host github
                     :repo "renzmann/treesit-auto")
    :demand t
    :config
    (add-to-list 'treesit-auto-fallback-alist '(bash-ts-mode . sh-mode))
    (treesit-auto-apply-remap)
    (advice-add 'treesit-install-language-grammar
                :after (lambda (&rest _r) (treesit-auto-apply-remap))))

  (setq c-ts-mode-hook c-mode-hook)
  (setq c++-ts-mode-hook c++-mode-hook)
  (setq python-ts-mode-hook python-mode-hook)
#+end_src

*** Happy Emacs!
Display a happy message :D
#+begin_src elisp
  (defun jd:happy-message ()
    "Display a happy message!"
    (message "Happy Emacs!"))
  (advice-add 'display-startup-echo-area-message :override #'jd:happy-message)
#+end_src

** Provide init.el

#+begin_src elisp
  (provide 'init)
  ;;; init.el ends here
#+end_src

#  LocalWords:  Init init Andrey's parens Smartparens flyspell gud gc lsp repo
#  LocalWords:  Magithub treemacs config Swiper swiper thres Clipetty eldoc 
#  LocalWords:  TOC minibuffer Ripgrep Yasnippet Eglot
